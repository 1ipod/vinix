From d27e4e79251a6f4de2f0308c99a77def948954d0 Mon Sep 17 00:00:00 2001
From: mintsuki <mintsuki@protonmail.com>
Date: Mon, 31 Jan 2022 15:25:10 +0100
Subject: [PATCH] Vinix specific changes

---
 abis/dripos/errno.h                           |    1 +
 abis/mlibc/signal.h                           |    6 +-
 meson.build                                   |    4 +
 options/ansi/generic/stdio-stubs.cpp          |    8 +-
 options/ansi/generic/stdlib-stubs.cpp         |    2 +-
 options/ansi/include/inttypes.h               |    1 +
 options/ansi/include/limits.h                 |    3 +
 options/ansi/include/mlibc/ansi-sysdeps.hpp   |    2 +
 .../include/mlibc/internal-sysdeps.hpp        |    4 +
 options/internal/include/mlibc/tcb.hpp        |    3 +
 options/internal/include/mlibc/thread.hpp     |    2 +
 options/internal/x86_64/thread.cpp            |    6 +
 options/linux-headers/include/asm/ioctls.h    |    2 +
 options/posix/generic/pthread-stubs.cpp       |  220 +-
 options/posix/generic/regex.cpp               |   23 -
 .../fnmatch.cpp => generic/regex/fnmatch.c}   |   13 +-
 .../glob.cpp => generic/regex/glob.c}         |   35 +-
 options/posix/generic/regex/regcomp.c         | 2953 +++++++++++++++++
 options/posix/generic/regex/regerror.c        |   35 +
 options/posix/generic/regex/regexec.c         | 1026 ++++++
 options/posix/generic/regex/tre-mem.c         |  158 +
 options/posix/generic/regex/tre.h             |  233 ++
 options/posix/generic/unistd-stubs.cpp        |    4 +-
 options/posix/include/mlibc/posix-sysdeps.hpp |    3 +-
 options/posix/include/pthread.h               |   41 +-
 options/posix/include/regex.h                 |    4 +-
 options/posix/meson.build                     |   11 +-
 options/rtdl/generic/linker.cpp               |    4 +-
 sysdeps/dripos/generic/generic.cpp            |    5 +-
 sysdeps/dripos/generic/thread.cpp             |   26 +-
 sysdeps/lemon/generic/lemon.cpp               |    5 +-
 sysdeps/lemon/generic/thread.cpp              |   26 +-
 sysdeps/linux/generic/sysdeps.cpp             |    4 +-
 sysdeps/linux/x86_64/thread.cpp               |   46 +-
 sysdeps/managarm/aarch64/thread.cpp           |   26 +-
 sysdeps/managarm/generic/fork-exec.cpp        |    7 +-
 sysdeps/managarm/x86_64/thread.cpp            |   26 +-
 sysdeps/vinix/crt-x86_64/crt0.S               |    5 +
 sysdeps/vinix/generic/entry.cpp               |   99 +
 sysdeps/vinix/generic/generic.cpp             |  785 +++++
 sysdeps/vinix/include/abi-bits/abi.h          |    1 +
 sysdeps/vinix/include/abi-bits/auxv.h         |    1 +
 sysdeps/vinix/include/abi-bits/blkcnt_t.h     |    1 +
 sysdeps/vinix/include/abi-bits/blksize_t.h    |    1 +
 sysdeps/vinix/include/abi-bits/dev_t.h        |    1 +
 sysdeps/vinix/include/abi-bits/errno.h        |    1 +
 sysdeps/vinix/include/abi-bits/fcntl.h        |    1 +
 sysdeps/vinix/include/abi-bits/gid_t.h        |    1 +
 sysdeps/vinix/include/abi-bits/in.h           |    1 +
 sysdeps/vinix/include/abi-bits/ino_t.h        |    1 +
 sysdeps/vinix/include/abi-bits/limits.h       |    1 +
 sysdeps/vinix/include/abi-bits/mode_t.h       |    1 +
 sysdeps/vinix/include/abi-bits/nlink_t.h      |    1 +
 sysdeps/vinix/include/abi-bits/pid_t.h        |    1 +
 sysdeps/vinix/include/abi-bits/reboot.h       |    1 +
 sysdeps/vinix/include/abi-bits/resource.h     |    1 +
 sysdeps/vinix/include/abi-bits/seek-whence.h  |    1 +
 sysdeps/vinix/include/abi-bits/signal.h       |    1 +
 sysdeps/vinix/include/abi-bits/socket.h       |    1 +
 sysdeps/vinix/include/abi-bits/stat.h         |    1 +
 sysdeps/vinix/include/abi-bits/termios.h      |    1 +
 sysdeps/vinix/include/abi-bits/time.h         |    1 +
 sysdeps/vinix/include/abi-bits/uid_t.h        |    1 +
 sysdeps/vinix/include/abi-bits/vm-flags.h     |    1 +
 sysdeps/vinix/include/abi-bits/wait.h         |    1 +
 sysdeps/vinix/meson.build                     |   52 +
 tests/ansi/sscanf.c                           |    7 +
 tests/meson.build                             |    1 +
 tests/posix/pthread_attr.c                    |  174 +
 69 files changed, 5939 insertions(+), 187 deletions(-)
 delete mode 100644 options/posix/generic/regex.cpp
 rename options/posix/{musl-generic/fnmatch.cpp => generic/regex/fnmatch.c} (96%)
 rename options/posix/{musl-generic/glob.cpp => generic/regex/glob.c} (89%)
 create mode 100644 options/posix/generic/regex/regcomp.c
 create mode 100644 options/posix/generic/regex/regerror.c
 create mode 100644 options/posix/generic/regex/regexec.c
 create mode 100644 options/posix/generic/regex/tre-mem.c
 create mode 100644 options/posix/generic/regex/tre.h
 create mode 100644 sysdeps/vinix/crt-x86_64/crt0.S
 create mode 100644 sysdeps/vinix/generic/entry.cpp
 create mode 100644 sysdeps/vinix/generic/generic.cpp
 create mode 120000 sysdeps/vinix/include/abi-bits/abi.h
 create mode 120000 sysdeps/vinix/include/abi-bits/auxv.h
 create mode 120000 sysdeps/vinix/include/abi-bits/blkcnt_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/blksize_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/dev_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/errno.h
 create mode 120000 sysdeps/vinix/include/abi-bits/fcntl.h
 create mode 120000 sysdeps/vinix/include/abi-bits/gid_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/in.h
 create mode 120000 sysdeps/vinix/include/abi-bits/ino_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/limits.h
 create mode 120000 sysdeps/vinix/include/abi-bits/mode_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/nlink_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/pid_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/reboot.h
 create mode 120000 sysdeps/vinix/include/abi-bits/resource.h
 create mode 120000 sysdeps/vinix/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/vinix/include/abi-bits/signal.h
 create mode 120000 sysdeps/vinix/include/abi-bits/socket.h
 create mode 120000 sysdeps/vinix/include/abi-bits/stat.h
 create mode 120000 sysdeps/vinix/include/abi-bits/termios.h
 create mode 120000 sysdeps/vinix/include/abi-bits/time.h
 create mode 120000 sysdeps/vinix/include/abi-bits/uid_t.h
 create mode 120000 sysdeps/vinix/include/abi-bits/vm-flags.h
 create mode 120000 sysdeps/vinix/include/abi-bits/wait.h
 create mode 100644 sysdeps/vinix/meson.build
 create mode 100644 tests/posix/pthread_attr.c

diff --git a/abis/dripos/errno.h b/abis/dripos/errno.h
index 700c1d2..44f56f3 100644
--- a/abis/dripos/errno.h
+++ b/abis/dripos/errno.h
@@ -109,5 +109,6 @@
 #define	EFTYPE		79		/* Inappropriate file type or format */
 #define EOVERFLOW   80
 #define EILSEQ      81
+#define ENOTSUP		82
 
 #endif
diff --git a/abis/mlibc/signal.h b/abis/mlibc/signal.h
index 5c63bca..eaf115b 100644
--- a/abis/mlibc/signal.h
+++ b/abis/mlibc/signal.h
@@ -127,10 +127,12 @@ struct sigevent {
 };
 
 struct sigaction {
-	void (*sa_handler)(int);
+    union {
+    	void (*sa_handler)(int);
+	    void (*sa_sigaction)(int, siginfo_t *, void *);
+	};
 	sigset_t sa_mask;
 	int sa_flags;
-	void (*sa_sigaction)(int, siginfo_t *, void *);
 };
 
 // TODO: this struct won't work on all arches (for example aarch64) but
diff --git a/meson.build b/meson.build
index 4027c99..3675409 100644
--- a/meson.build
+++ b/meson.build
@@ -110,6 +110,10 @@ elif host_machine.system() == 'qword'
 	rtdl_include_dirs += include_directories('sysdeps/qword/include')
 	libc_include_dirs += include_directories('sysdeps/qword/include')
 	subdir('sysdeps/qword')
+elif host_machine.system() == 'vinix'
+	rtdl_include_dirs += include_directories('sysdeps/vinix/include')
+	libc_include_dirs += include_directories('sysdeps/vinix/include')
+	subdir('sysdeps/vinix')
 elif host_machine.system() == 'sigma'
 	#disable_linux_option = true
 	rtdl_include_dirs += include_directories('sysdeps/sigma/include')
diff --git a/options/ansi/generic/stdio-stubs.cpp b/options/ansi/generic/stdio-stubs.cpp
index eb80feb..9c65f8b 100644
--- a/options/ansi/generic/stdio-stubs.cpp
+++ b/options/ansi/generic/stdio-stubs.cpp
@@ -497,10 +497,10 @@ static int do_scanf(H &handler, const char *fmt, __gnuc_va_list args) {
                                 res = res * 16 + (c - '0');
                             } else if (c >= 'a' && c <= 'f') {
                                 handler.consume();
-                                res = res * 16 + (c - 'a');
+                                res = res * 16 + (c - 'a' + 10);
                             } else if (c >= 'A' && c <= 'F') {
                                 handler.consume();
-                                res = res * 16 + (c - 'A');
+                                res = res * 16 + (c - 'A' + 10);
                             } else {
                                 break;
                             }
@@ -549,10 +549,10 @@ static int do_scanf(H &handler, const char *fmt, __gnuc_va_list args) {
                         res = res * 16 + (c - '0');
                     } else if (c >= 'a' && c <= 'f') {
                         handler.consume();
-                        res = res * 16 + (c - 'a');
+                        res = res * 16 + (c - 'a' + 10);
                     } else if (c >= 'A' && c <= 'F') {
                         handler.consume();
-                        res = res * 16 + (c - 'A');
+                        res = res * 16 + (c - 'A' + 10);
                     } else {
                         break;
                     }
diff --git a/options/ansi/generic/stdlib-stubs.cpp b/options/ansi/generic/stdlib-stubs.cpp
index 347c659..e150d33 100644
--- a/options/ansi/generic/stdlib-stubs.cpp
+++ b/options/ansi/generic/stdlib-stubs.cpp
@@ -428,7 +428,7 @@ int mblen(const char *mbs, size_t mb_limit) {
 }
 
 int mbtowc(wchar_t *__restrict wc, const char *__restrict mbs, size_t max_size) {
-	mlibc::infoLogger() << "mlibc: Broken mbtowc() called" << frg::endlog;
+	//mlibc::infoLogger() << "mlibc: Broken mbtowc() called" << frg::endlog;
 	__ensure(max_size);
 
 	if(wc && mbs){
diff --git a/options/ansi/include/inttypes.h b/options/ansi/include/inttypes.h
index be9b874..968a849 100644
--- a/options/ansi/include/inttypes.h
+++ b/options/ansi/include/inttypes.h
@@ -95,6 +95,7 @@
 #define SCNx32 "x"
 #define SCNx64 "lx"
 #define SCNxMAX "lx"
+#define SCNxPTR "lx"
 
 #define SCNd64 "ld"
 
diff --git a/options/ansi/include/limits.h b/options/ansi/include/limits.h
index 300c436..a2883b0 100644
--- a/options/ansi/include/limits.h
+++ b/options/ansi/include/limits.h
@@ -32,6 +32,9 @@
 #define LINE_MAX 4096
 #define PIPE_BUF 4096
 
+#define CHARCLASS_NAME_MAX 14
+#define RE_DUP_MAX 255
+
 // This value is a guaranteed minimum, get the current maximum from sysconf
 #define NGROUPS_MAX 8
 // POSIX states 9 is the minimum for NL_ARGMAX
diff --git a/options/ansi/include/mlibc/ansi-sysdeps.hpp b/options/ansi/include/mlibc/ansi-sysdeps.hpp
index fe81c4e..a54b513 100644
--- a/options/ansi/include/mlibc/ansi-sysdeps.hpp
+++ b/options/ansi/include/mlibc/ansi-sysdeps.hpp
@@ -6,6 +6,7 @@
 #include <abi-bits/seek-whence.h>
 #include <abi-bits/vm-flags.h>
 #include <abi-bits/pid_t.h>
+#include <abi-bits/gid_t.h>
 #include <bits/off_t.h>
 #include <bits/ssize_t.h>
 #include <bits/ansi/time_t.h>
@@ -53,6 +54,7 @@ int sys_clock_get(int clock, time_t *secs, long *nanos);
 [[gnu::weak]] int sys_execve(const char *path, char *const argv[], char *const envp[]);
 
 [[gnu::weak]] pid_t sys_getpid();
+[[gnu::weak]] int sys_getgroups(size_t size, const gid_t *list, int *ret);
 [[gnu::weak]] int sys_kill(int, int);
 
 } //namespace mlibc
diff --git a/options/internal/include/mlibc/internal-sysdeps.hpp b/options/internal/include/mlibc/internal-sysdeps.hpp
index d5f5a00..e56e30c 100644
--- a/options/internal/include/mlibc/internal-sysdeps.hpp
+++ b/options/internal/include/mlibc/internal-sysdeps.hpp
@@ -9,6 +9,7 @@
 #include <bits/ssize_t.h>
 #include <abi-bits/stat.h>
 #include <mlibc/fsfd_target.hpp>
+#include <bits/posix/posix_signal.h>
 
 namespace [[gnu::visibility("hidden")]] mlibc {
 
@@ -35,6 +36,9 @@ int sys_close(int fd);
 int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window);
 int sys_vm_unmap(void *pointer, size_t size);
 
+int sys_sigentry(void *pointer);
+[[noreturn]] int sys_sigreturn(void *context, sigset_t old_mask);
+
 } //namespace mlibc
 
 #endif // MLIBC_INTERNAL_SYSDEPS
diff --git a/options/internal/include/mlibc/tcb.hpp b/options/internal/include/mlibc/tcb.hpp
index f8a3fe8..962a1c9 100644
--- a/options/internal/include/mlibc/tcb.hpp
+++ b/options/internal/include/mlibc/tcb.hpp
@@ -107,5 +107,8 @@ struct Tcb {
 	CleanupHandler *cleanupBegin;
 	CleanupHandler *cleanupEnd;
 	int isJoinable;
+	size_t stackSize;
+	void *stackAddr;
+	size_t guardSize;
 };
 
diff --git a/options/internal/include/mlibc/thread.hpp b/options/internal/include/mlibc/thread.hpp
index 0781966..0909e18 100644
--- a/options/internal/include/mlibc/thread.hpp
+++ b/options/internal/include/mlibc/thread.hpp
@@ -1,9 +1,11 @@
 #pragma once
 
 #include <mlibc/tcb.hpp>
+#include <stdint.h>
 
 namespace mlibc {
 
 Tcb *get_current_tcb();
+uintptr_t get_sp();
 
 } // namespace mlibc
diff --git a/options/internal/x86_64/thread.cpp b/options/internal/x86_64/thread.cpp
index ae0b023..6b320cd 100644
--- a/options/internal/x86_64/thread.cpp
+++ b/options/internal/x86_64/thread.cpp
@@ -10,4 +10,10 @@ Tcb *get_current_tcb() {
 	return reinterpret_cast<Tcb *>(ptr);
 }
 
+uintptr_t get_sp() {
+	uintptr_t rsp;
+	asm ("mov %%rsp, %0" : "=r"(rsp));
+	return rsp;
+}
+
 } // namespace mlibc
diff --git a/options/linux-headers/include/asm/ioctls.h b/options/linux-headers/include/asm/ioctls.h
index 41d4248..f246d1d 100644
--- a/options/linux-headers/include/asm/ioctls.h
+++ b/options/linux-headers/include/asm/ioctls.h
@@ -5,6 +5,8 @@
 
 #define TCGETS 0x5401
 #define TCSETS 0x5402
+#define TCSETSW 0x5403
+#define TCSETSF 0x5404
 #define TIOCSCTTY 0x540E
 #define TIOCSTI 0x5412
 #define TIOCGWINSZ 0x5413
diff --git a/options/posix/generic/pthread-stubs.cpp b/options/posix/generic/pthread-stubs.cpp
index 90ba98c..8a79be7 100644
--- a/options/posix/generic/pthread-stubs.cpp
+++ b/options/posix/generic/pthread-stubs.cpp
@@ -1,10 +1,12 @@
 
 #include <stddef.h>
 #include <stdint.h>
+#include <stdio.h>
 #include <string.h>
 #include <pthread.h>
 #include <unistd.h>
 #include <errno.h>
+#include <inttypes.h>
 
 #include <bits/ensure.h>
 #include <frg/allocation.hpp>
@@ -63,12 +65,19 @@ static constexpr unsigned int mutex_excl_bit = static_cast<uint32_t>(1) << 30;
 static constexpr unsigned int rc_count_mask = (static_cast<uint32_t>(1) << 31) - 1;
 static constexpr unsigned int rc_waiters_bit = static_cast<uint32_t>(1) << 31;
 
+static constexpr size_t default_stacksize = 0x200000;
+static constexpr size_t default_guardsize = 4096;
+
 // ----------------------------------------------------------------------------
 // pthread_attr and pthread functions.
 // ----------------------------------------------------------------------------
 
 // pthread_attr functions.
-int pthread_attr_init(pthread_attr_t *) {
+int pthread_attr_init(pthread_attr_t *attr) {
+	*attr = pthread_attr_t{};
+	attr->__mlibc_stacksize = default_stacksize;
+	attr->__mlibc_guardsize = default_guardsize;
+	attr->__mlibc_detachstate = PTHREAD_CREATE_JOINABLE;
 	return 0;
 }
 
@@ -76,84 +85,190 @@ int pthread_attr_destroy(pthread_attr_t *) {
 	return 0;
 }
 
-int pthread_attr_getdetachstate(const pthread_attr_t *, int *) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate) {
+	*detachstate = attr->__mlibc_detachstate;
+	return 0;
 }
+int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate) {
+	if (detachstate != PTHREAD_CREATE_DETACHED &&
+			detachstate != PTHREAD_CREATE_JOINABLE)
+		return EINVAL;
 
-int pthread_attr_setdetachstate(pthread_attr_t *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	attr->__mlibc_detachstate = detachstate;
+	return 0;
 }
 
-int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getstacksize(const pthread_attr_t *__restrict attr, size_t *__restrict stacksize) {
+	*stacksize = attr->__mlibc_stacksize;
+	return 0;
 }
 
-int pthread_attr_setstacksize(pthread_attr_t *, size_t) {
-	mlibc::infoLogger() << "mlibc: pthread_attr_setstacksize() is not implemented correctly" << frg::endlog;
+int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize) {
+	if (stacksize < PTHREAD_STACK_MIN)
+		return EINVAL;
+	attr->__mlibc_stacksize = stacksize;
 	return 0;
 }
 
-int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr) {
+	*stackaddr = attr->__mlibc_stackaddr;
+	return 0;
 }
-
-int pthread_attr_setguardsize(pthread_attr_t *, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr) {
+	attr->__mlibc_stackaddr = stackaddr;
+	return 0;
 }
 
-int pthread_attr_getscope(const pthread_attr_t *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize) {
+	*stackaddr = attr->__mlibc_stackaddr;
+	*stacksize = attr->__mlibc_stacksize;
+	return 0;
+}
+int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize) {
+	if (stacksize < PTHREAD_STACK_MIN)
+		return EINVAL;
+	attr->__mlibc_stacksize = stacksize;
+	attr->__mlibc_stackaddr = stackaddr;
+	return 0;
 }
 
-int pthread_attr_setscope(pthread_attr_t *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getguardsize(const pthread_attr_t *__restrict attr, size_t *__restrict guardsize) {
+	*guardsize = attr->__mlibc_guardsize;
+	return 0;
+}
+int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize) {
+	attr->__mlibc_guardsize = guardsize;
+	return 0;
 }
 
-int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getscope(const pthread_attr_t *attr, int *scope) {
+	*scope = attr->__mlibc_scope;
+	return 0;
+}
+int pthread_attr_setscope(pthread_attr_t *attr, int scope) {
+	if (scope != PTHREAD_SCOPE_SYSTEM &&
+			scope != PTHREAD_SCOPE_PROCESS)
+		return EINVAL;
+	if (scope == PTHREAD_SCOPE_PROCESS)
+		return ENOTSUP;
+	attr->__mlibc_scope = scope;
+	return 0;
 }
 
-int pthread_attr_setschedpolicy(pthread_attr_t *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched) {
+	*inheritsched = attr->__mlibc_inheritsched;
+	return 0;
+}
+int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched) {
+	if (inheritsched != PTHREAD_INHERIT_SCHED &&
+			inheritsched != PTHREAD_EXPLICIT_SCHED)
+		return EINVAL;
+	attr->__mlibc_inheritsched = inheritsched;
+	return 0;
 }
 
-int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getschedparam(const pthread_attr_t *__restrict attr, struct sched_param *__restrict schedparam) {
+	*schedparam = attr->__mlibc_schedparam;
+	return 0;
+}
+int pthread_attr_setschedparam(pthread_attr_t *__restrict attr, const struct sched_param *__restrict schedparam) {
+	// TODO: this is supposed to return EINVAL for when the schedparam doesn't make sense
+	// for the given schedpolicy.
+	attr->__mlibc_schedparam = *schedparam;
+	return 0;
 }
 
-int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict attr, int *__restrict policy) {
+	*policy = attr->__mlibc_schedpolicy;
+	return 0;
+}
+int pthread_attr_setschedpolicy(pthread_attr_t *__restrict attr, int policy) {
+	if (policy != SCHED_FIFO && policy != SCHED_RR &&
+			policy != SCHED_OTHER)
+		return EINVAL;
+	attr->__mlibc_schedpolicy = policy;
+	return 0;
 }
 
-int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+namespace {
+	void get_own_stackinfo(void **stack_addr, size_t *stack_size) {
+		auto fp = fopen("/proc/self/maps", "r");
+		if (!fp) {
+			mlibc::infoLogger() << "mlibc pthreads: /proc/self/maps does not exist! Producing incorrect"
+				" stack results!" << frg::endlog;
+			return;
+		}
+
+		char line[256];
+		auto sp = mlibc::get_sp();
+		while (fgets(line, 128, fp)) {
+			uintptr_t from, to;
+			if(sscanf(line, "%lx-%lx", &from, &to) != 2)
+				continue;
+			if (sp < to && sp > from) {
+				// We need to return the lowest byte of the stack.
+				*stack_addr = reinterpret_cast<void*>(from);
+				*stack_size = to - from;
+				fclose(fp);
+				return;
+			}
+		}
+
+		fclose(fp);
+	}
 }
 
-int pthread_attr_setinheritsched(pthread_attr_t *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr) {
+	auto tcb = reinterpret_cast<Tcb*>(thread);
+	*attr = pthread_attr_t{};
+
+	if (!tcb->stackAddr || !tcb->stackSize) {
+		get_own_stackinfo(&attr->__mlibc_stackaddr, &attr->__mlibc_stacksize);
+	} else {
+		attr->__mlibc_stacksize = tcb->stackSize;
+		attr->__mlibc_stackaddr = tcb->stackAddr;
+	}
+
+	attr->__mlibc_guardsize = tcb->guardSize;
+	attr->__mlibc_detachstate = tcb->isJoinable ? PTHREAD_CREATE_JOINABLE : PTHREAD_CREATE_DETACHED;
+	mlibc::infoLogger() << "pthread_getattr_np(): Implementation is incomplete!" << frg::endlog;
+	return 0;
 }
 
 extern "C" Tcb *__rtdl_allocateTcb();
 
 // pthread functions.
-int pthread_create(pthread_t *__restrict thread, const pthread_attr_t *__restrict,
+int pthread_create(pthread_t *__restrict thread, const pthread_attr_t *__restrict attrp,
 		void *(*entry) (void *), void *__restrict user_arg) {
 	auto new_tcb = __rtdl_allocateTcb();
 	pid_t tid;
-	mlibc::sys_clone(reinterpret_cast<void *>(entry), user_arg, new_tcb, &tid);
+	pthread_attr_t attr = {};
+	if (!attrp)
+		pthread_attr_init(&attr);
+	else
+		attr = *attrp;
+
+	// TODO: due to alignment guarantees, the stackaddr and stacksize might change
+	// when the stack is allocated. Currently this isn't propagated to the TCB,
+	// but it should be.
+	void *stack = attr.__mlibc_stackaddr;
+	if (!mlibc::sys_prepare_stack) {
+		MLIBC_MISSING_SYSDEP();
+		return ENOSYS;
+	}
+	int ret = mlibc::sys_prepare_stack(&stack, reinterpret_cast<void*>(entry),
+			user_arg, new_tcb, &attr.__mlibc_stacksize, &attr.__mlibc_guardsize);
+	if (ret)
+		return ret;
+
+	if (!mlibc::sys_clone) {
+		MLIBC_MISSING_SYSDEP();
+		return ENOSYS;
+	}
+	new_tcb->stackSize = attr.__mlibc_stacksize;
+	new_tcb->guardSize = attr.__mlibc_guardsize;
+	new_tcb->stackAddr = stack - attr.__mlibc_stacksize - attr.__mlibc_guardsize;
+	mlibc::sys_clone(new_tcb, &tid, stack);
 	*thread = reinterpret_cast<pthread_t>(new_tcb);
 
 	__atomic_store_n(&new_tcb->tid, tid, __ATOMIC_RELAXED);
@@ -312,21 +427,6 @@ int pthread_getname_np(pthread_t, char *, size_t) {
 	__builtin_unreachable();
 }
 
-int pthread_attr_setstack(pthread_attr_t *, void *, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
-}
-
-int pthread_attr_getstack(const pthread_attr_t *, void **, size_t *) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
-}
-
-int pthread_getattr_np(pthread_t, pthread_attr_t *) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
-}
-
 int pthread_setschedparam(pthread_t, int, const struct sched_param *) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
diff --git a/options/posix/generic/regex.cpp b/options/posix/generic/regex.cpp
deleted file mode 100644
index c937162..0000000
--- a/options/posix/generic/regex.cpp
+++ /dev/null
@@ -1,23 +0,0 @@
-#include <regex.h>
-
-#include <bits/ensure.h>
-
-int regcomp(regex_t *__restrict, const char *__restrict, int) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
-}
-
-int regexec(const regex_t *__restrict, const char *__restrict, size_t, regmatch_t *__restrict, int) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
-}
-
-size_t regerror(int, const regex_t *__restrict, char *__restrict, size_t) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
-}
-
-void regfree(regex_t *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
-}
diff --git a/options/posix/musl-generic/fnmatch.cpp b/options/posix/generic/regex/fnmatch.c
similarity index 96%
rename from options/posix/musl-generic/fnmatch.cpp
rename to options/posix/generic/regex/fnmatch.c
index 402225e..9e90852 100644
--- a/options/posix/musl-generic/fnmatch.cpp
+++ b/options/posix/generic/regex/fnmatch.c
@@ -18,7 +18,6 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
-//#include "locale_impl.h"
 
 #define END 0
 #define UNMATCHABLE -2
@@ -32,7 +31,7 @@ static int str_next(const char *str, size_t n, size_t *step)
 		*step = 0;
 		return 0;
 	}
-	if ((unsigned char)str[0] >= 128U) {
+	if (str[0] >= 128U) {
 		wchar_t wc;
 		int k = mbtowc(&wc, str, n);
 		if (k<0) {
@@ -85,7 +84,7 @@ static int pat_next(const char *pat, size_t m, size_t *step, int flags)
 	if (pat[0] == '?')
 		return QUESTION;
 escaped:
-	if ((unsigned char)pat[0] >= 128U) {
+	if (pat[0] >= 128U) {
 		wchar_t wc;
 		int k = mbtowc(&wc, pat, m);
 		if (k<0) {
@@ -127,8 +126,8 @@ static int match_bracket(const char *p, int k, int kfold)
 			int l = mbtowc(&wc2, p+1, 4);
 			if (l < 0) return 0;
 			if (wc <= wc2)
-				if ((unsigned)k-wc <= (unsigned)wc2-wc ||
-				    (unsigned)kfold-wc <= (unsigned)wc2-wc)
+				if ((unsigned)k-wc <= wc2-wc ||
+				    (unsigned)kfold-wc <= wc2-wc)
 					return !inv;
 			p += l-1;
 			continue;
@@ -148,7 +147,7 @@ static int match_bracket(const char *p, int k, int kfold)
 			}
 			continue;
 		}
-		if ((unsigned char)*p < 128U) {
+		if (*p < 128U) {
 			wc = (unsigned char)*p;
 		} else {
 			int l = mbtowc(&wc, p, 4);
@@ -230,7 +229,7 @@ static int fnmatch_internal(const char *pat, size_t m, const char *str, size_t n
 	 * On illegal sequences we may get it wrong, but in that case
 	 * we necessarily have a matching failure anyway. */
 	for (s=endstr; s>str && tailcnt; tailcnt--) {
-		if ((unsigned char)s[-1] < 128U || MB_CUR_MAX==1) s--;
+		if (s[-1] < 128U || MB_CUR_MAX==1) s--;
 		else while ((unsigned char)*--s-0x80U<0x40 && s>str);
 	}
 	if (tailcnt) return FNM_NOMATCH;
diff --git a/options/posix/musl-generic/glob.cpp b/options/posix/generic/regex/glob.c
similarity index 89%
rename from options/posix/musl-generic/glob.cpp
rename to options/posix/generic/regex/glob.c
index cd35234..fdedbfa 100644
--- a/options/posix/musl-generic/glob.cpp
+++ b/options/posix/generic/regex/glob.c
@@ -1,3 +1,4 @@
+#define _BSD_SOURCE
 #include <glob.h>
 #include <fnmatch.h>
 #include <sys/stat.h>
@@ -10,6 +11,9 @@
 #include <unistd.h>
 #include <pwd.h>
 
+#define weak_alias(old, new) \
+	extern __typeof(old) new __attribute__((__weak__, __alias__(#old)))
+
 struct match
 {
 	struct match *next;
@@ -18,16 +22,16 @@ struct match
 
 static int append(struct match **tail, const char *name, size_t len, int mark)
 {
-	struct match *m = reinterpret_cast<struct match *>(malloc(sizeof(struct match) + len + 2));
-	if (!m) return -1;
-	(*tail)->next = m;
-	m->next = NULL;
-	memcpy(m->name, name, len+1);
+	struct match *new = malloc(sizeof(struct match) + len + 2);
+	if (!new) return -1;
+	(*tail)->next = new;
+	new->next = NULL;
+	memcpy(new->name, name, len+1);
 	if (mark && len && name[len-1]!='/') {
-		m->name[len] = '/';
-		m->name[len+1] = 0;
+		new->name[len] = '/';
+		new->name[len+1] = 0;
 	}
-	*tail = m;
+	*tail = new;
 	return 0;
 }
 
@@ -150,13 +154,13 @@ static int do_glob(char *buf, size_t pos, int type, char *pat, int flags, int (*
 		/* With GLOB_PERIOD, don't allow matching . or .. unless
 		 * fnmatch would match them with FNM_PERIOD rules in effect. */
 		if (p2 && (flags & GLOB_PERIOD) && de->d_name[0]=='.'
-		    && (!de->d_name[1] || (de->d_name[1]=='.' && !de->d_name[2]))
+		    && (!de->d_name[1] || de->d_name[1]=='.' && !de->d_name[2])
 		    && fnmatch(pat, de->d_name, fnm_flags | FNM_PERIOD))
 			continue;
 
 		memcpy(buf+pos, de->d_name, l+1);
 		if (p2) *p2 = saved_sep;
-		int r = do_glob(buf, pos+l, de->d_type, p2 ? p2 : const_cast<char *>(""), flags, errfunc, tail);
+		int r = do_glob(buf, pos+l, de->d_type, p2 ? p2 : "", flags, errfunc, tail);
 		if (r) {
 			closedir(dir);
 			return r;
@@ -171,7 +175,7 @@ static int do_glob(char *buf, size_t pos, int type, char *pat, int flags, int (*
 	return 0;
 }
 
-static int ignore_err(const char *, int)
+static int ignore_err(const char *path, int err)
 {
 	return 0;
 }
@@ -223,7 +227,7 @@ static int expand_tilde(char **pat, char *buf, size_t *pos)
 	return 0;
 }
 
-int glob(const char *__restrict pat, int flags, int (*errfunc)(const char *path, int err), glob_t *__restrict g)
+int glob(const char *restrict pat, int flags, int (*errfunc)(const char *path, int err), glob_t *restrict g)
 {
 	struct match head = { .next = NULL }, *tail = &head;
 	size_t cnt, i;
@@ -269,7 +273,7 @@ int glob(const char *__restrict pat, int flags, int (*errfunc)(const char *path,
 	}
 
 	if (flags & GLOB_APPEND) {
-		char **pathv = reinterpret_cast<char **>(realloc(g->gl_pathv, (offs + g->gl_pathc + cnt + 1) * sizeof(char *)));
+		char **pathv = realloc(g->gl_pathv, (offs + g->gl_pathc + cnt + 1) * sizeof(char *));
 		if (!pathv) {
 			freelist(&head);
 			return GLOB_NOSPACE;
@@ -277,7 +281,7 @@ int glob(const char *__restrict pat, int flags, int (*errfunc)(const char *path,
 		g->gl_pathv = pathv;
 		offs += g->gl_pathc;
 	} else {
-		g->gl_pathv = reinterpret_cast<char **>(malloc((offs + cnt + 1) * sizeof(char *)));
+		g->gl_pathv = malloc((offs + cnt + 1) * sizeof(char *));
 		if (!g->gl_pathv) {
 			freelist(&head);
 			return GLOB_NOSPACE;
@@ -305,3 +309,6 @@ void globfree(glob_t *g)
 	g->gl_pathc = 0;
 	g->gl_pathv = NULL;
 }
+
+weak_alias(glob, glob64);
+weak_alias(globfree, globfree64);
diff --git a/options/posix/generic/regex/regcomp.c b/options/posix/generic/regex/regcomp.c
new file mode 100644
index 0000000..fb24556
--- /dev/null
+++ b/options/posix/generic/regex/regcomp.c
@@ -0,0 +1,2953 @@
+/*
+  regcomp.c - TRE POSIX compatible regex compilation functions.
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <string.h>
+#include <stdlib.h>
+#include <regex.h>
+#include <limits.h>
+#include <stdint.h>
+#include <ctype.h>
+
+#include "tre.h"
+
+#include <assert.h>
+
+/***********************************************************************
+ from tre-compile.h
+***********************************************************************/
+
+typedef struct {
+  int position;
+  int code_min;
+  int code_max;
+  int *tags;
+  int assertions;
+  tre_ctype_t class;
+  tre_ctype_t *neg_classes;
+  int backref;
+} tre_pos_and_tags_t;
+
+
+/***********************************************************************
+ from tre-ast.c and tre-ast.h
+***********************************************************************/
+
+/* The different AST node types. */
+typedef enum {
+  LITERAL,
+  CATENATION,
+  ITERATION,
+  UNION
+} tre_ast_type_t;
+
+/* Special subtypes of TRE_LITERAL. */
+#define EMPTY	  -1   /* Empty leaf (denotes empty string). */
+#define ASSERTION -2   /* Assertion leaf. */
+#define TAG	  -3   /* Tag leaf. */
+#define BACKREF	  -4   /* Back reference leaf. */
+
+#define IS_SPECIAL(x)	((x)->code_min < 0)
+#define IS_EMPTY(x)	((x)->code_min == EMPTY)
+#define IS_ASSERTION(x) ((x)->code_min == ASSERTION)
+#define IS_TAG(x)	((x)->code_min == TAG)
+#define IS_BACKREF(x)	((x)->code_min == BACKREF)
+
+
+/* A generic AST node.  All AST nodes consist of this node on the top
+   level with `obj' pointing to the actual content. */
+typedef struct {
+  tre_ast_type_t type;   /* Type of the node. */
+  void *obj;             /* Pointer to actual node. */
+  int nullable;
+  int submatch_id;
+  int num_submatches;
+  int num_tags;
+  tre_pos_and_tags_t *firstpos;
+  tre_pos_and_tags_t *lastpos;
+} tre_ast_node_t;
+
+
+/* A "literal" node.  These are created for assertions, back references,
+   tags, matching parameter settings, and all expressions that match one
+   character. */
+typedef struct {
+  long code_min;
+  long code_max;
+  int position;
+  tre_ctype_t class;
+  tre_ctype_t *neg_classes;
+} tre_literal_t;
+
+/* A "catenation" node.	 These are created when two regexps are concatenated.
+   If there are more than one subexpressions in sequence, the `left' part
+   holds all but the last, and `right' part holds the last subexpression
+   (catenation is left associative). */
+typedef struct {
+  tre_ast_node_t *left;
+  tre_ast_node_t *right;
+} tre_catenation_t;
+
+/* An "iteration" node.	 These are created for the "*", "+", "?", and "{m,n}"
+   operators. */
+typedef struct {
+  /* Subexpression to match. */
+  tre_ast_node_t *arg;
+  /* Minimum number of consecutive matches. */
+  int min;
+  /* Maximum number of consecutive matches. */
+  int max;
+  /* If 0, match as many characters as possible, if 1 match as few as
+     possible.	Note that this does not always mean the same thing as
+     matching as many/few repetitions as possible. */
+  unsigned int minimal:1;
+} tre_iteration_t;
+
+/* An "union" node.  These are created for the "|" operator. */
+typedef struct {
+  tre_ast_node_t *left;
+  tre_ast_node_t *right;
+} tre_union_t;
+
+
+static tre_ast_node_t *
+tre_ast_new_node(tre_mem_t mem, int type, void *obj)
+{
+	tre_ast_node_t *node = tre_mem_calloc(mem, sizeof *node);
+	if (!node || !obj)
+		return 0;
+	node->obj = obj;
+	node->type = type;
+	node->nullable = -1;
+	node->submatch_id = -1;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_literal(tre_mem_t mem, int code_min, int code_max, int position)
+{
+	tre_ast_node_t *node;
+	tre_literal_t *lit;
+
+	lit = tre_mem_calloc(mem, sizeof *lit);
+	node = tre_ast_new_node(mem, LITERAL, lit);
+	if (!node)
+		return 0;
+	lit->code_min = code_min;
+	lit->code_max = code_max;
+	lit->position = position;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_iter(tre_mem_t mem, tre_ast_node_t *arg, int min, int max, int minimal)
+{
+	tre_ast_node_t *node;
+	tre_iteration_t *iter;
+
+	iter = tre_mem_calloc(mem, sizeof *iter);
+	node = tre_ast_new_node(mem, ITERATION, iter);
+	if (!node)
+		return 0;
+	iter->arg = arg;
+	iter->min = min;
+	iter->max = max;
+	iter->minimal = minimal;
+	node->num_submatches = arg->num_submatches;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_union(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
+{
+	tre_ast_node_t *node;
+	tre_union_t *un;
+
+	if (!left)
+		return right;
+	un = tre_mem_calloc(mem, sizeof *un);
+	node = tre_ast_new_node(mem, UNION, un);
+	if (!node || !right)
+		return 0;
+	un->left = left;
+	un->right = right;
+	node->num_submatches = left->num_submatches + right->num_submatches;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_catenation(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
+{
+	tre_ast_node_t *node;
+	tre_catenation_t *cat;
+
+	if (!left)
+		return right;
+	cat = tre_mem_calloc(mem, sizeof *cat);
+	node = tre_ast_new_node(mem, CATENATION, cat);
+	if (!node)
+		return 0;
+	cat->left = left;
+	cat->right = right;
+	node->num_submatches = left->num_submatches + right->num_submatches;
+	return node;
+}
+
+
+/***********************************************************************
+ from tre-stack.c and tre-stack.h
+***********************************************************************/
+
+typedef struct tre_stack_rec tre_stack_t;
+
+/* Creates a new stack object.	`size' is initial size in bytes, `max_size'
+   is maximum size, and `increment' specifies how much more space will be
+   allocated with realloc() if all space gets used up.	Returns the stack
+   object or NULL if out of memory. */
+static tre_stack_t *
+tre_stack_new(int size, int max_size, int increment);
+
+/* Frees the stack object. */
+static void
+tre_stack_destroy(tre_stack_t *s);
+
+/* Returns the current number of objects in the stack. */
+static int
+tre_stack_num_objects(tre_stack_t *s);
+
+/* Each tre_stack_push_*(tre_stack_t *s, <type> value) function pushes
+   `value' on top of stack `s'.  Returns REG_ESPACE if out of memory.
+   This tries to realloc() more space before failing if maximum size
+   has not yet been reached.  Returns REG_OK if successful. */
+#define declare_pushf(typetag, type)					      \
+  static reg_errcode_t tre_stack_push_ ## typetag(tre_stack_t *s, type value)
+
+declare_pushf(voidptr, void *);
+declare_pushf(int, int);
+
+/* Each tre_stack_pop_*(tre_stack_t *s) function pops the topmost
+   element off of stack `s' and returns it.  The stack must not be
+   empty. */
+#define declare_popf(typetag, type)		  \
+  static type tre_stack_pop_ ## typetag(tre_stack_t *s)
+
+declare_popf(voidptr, void *);
+declare_popf(int, int);
+
+/* Just to save some typing. */
+#define STACK_PUSH(s, typetag, value)					      \
+  do									      \
+    {									      \
+      status = tre_stack_push_ ## typetag(s, value);			      \
+    }									      \
+  while (/*CONSTCOND*/0)
+
+#define STACK_PUSHX(s, typetag, value)					      \
+  {									      \
+    status = tre_stack_push_ ## typetag(s, value);			      \
+    if (status != REG_OK)						      \
+      break;								      \
+  }
+
+#define STACK_PUSHR(s, typetag, value)					      \
+  {									      \
+    reg_errcode_t _status;						      \
+    _status = tre_stack_push_ ## typetag(s, value);			      \
+    if (_status != REG_OK)						      \
+      return _status;							      \
+  }
+
+union tre_stack_item {
+  void *voidptr_value;
+  int int_value;
+};
+
+struct tre_stack_rec {
+  int size;
+  int max_size;
+  int increment;
+  int ptr;
+  union tre_stack_item *stack;
+};
+
+
+static tre_stack_t *
+tre_stack_new(int size, int max_size, int increment)
+{
+  tre_stack_t *s;
+
+  s = xmalloc(sizeof(*s));
+  if (s != NULL)
+    {
+      s->stack = xmalloc(sizeof(*s->stack) * size);
+      if (s->stack == NULL)
+	{
+	  xfree(s);
+	  return NULL;
+	}
+      s->size = size;
+      s->max_size = max_size;
+      s->increment = increment;
+      s->ptr = 0;
+    }
+  return s;
+}
+
+static void
+tre_stack_destroy(tre_stack_t *s)
+{
+  xfree(s->stack);
+  xfree(s);
+}
+
+static int
+tre_stack_num_objects(tre_stack_t *s)
+{
+  return s->ptr;
+}
+
+static reg_errcode_t
+tre_stack_push(tre_stack_t *s, union tre_stack_item value)
+{
+  if (s->ptr < s->size)
+    {
+      s->stack[s->ptr] = value;
+      s->ptr++;
+    }
+  else
+    {
+      if (s->size >= s->max_size)
+	{
+	  return REG_ESPACE;
+	}
+      else
+	{
+	  union tre_stack_item *new_buffer;
+	  int new_size;
+	  new_size = s->size + s->increment;
+	  if (new_size > s->max_size)
+	    new_size = s->max_size;
+	  new_buffer = xrealloc(s->stack, sizeof(*new_buffer) * new_size);
+	  if (new_buffer == NULL)
+	    {
+	      return REG_ESPACE;
+	    }
+	  assert(new_size > s->size);
+	  s->size = new_size;
+	  s->stack = new_buffer;
+	  tre_stack_push(s, value);
+	}
+    }
+  return REG_OK;
+}
+
+#define define_pushf(typetag, type)  \
+  declare_pushf(typetag, type) {     \
+    union tre_stack_item item;	     \
+    item.typetag ## _value = value;  \
+    return tre_stack_push(s, item);  \
+}
+
+define_pushf(int, int)
+define_pushf(voidptr, void *)
+
+#define define_popf(typetag, type)		    \
+  declare_popf(typetag, type) {			    \
+    return s->stack[--s->ptr].typetag ## _value;    \
+  }
+
+define_popf(int, int)
+define_popf(voidptr, void *)
+
+
+/***********************************************************************
+ from tre-parse.c and tre-parse.h
+***********************************************************************/
+
+/* Parse context. */
+typedef struct {
+	/* Memory allocator. The AST is allocated using this. */
+	tre_mem_t mem;
+	/* Stack used for keeping track of regexp syntax. */
+	tre_stack_t *stack;
+	/* The parsed node after a parse function returns. */
+	tre_ast_node_t *n;
+	/* Position in the regexp pattern after a parse function returns. */
+	const char *s;
+	/* The first character of the last subexpression parsed. */
+	const char *start;
+	/* Current submatch ID. */
+	int submatch_id;
+	/* Current position (number of literal). */
+	int position;
+	/* The highest back reference or -1 if none seen so far. */
+	int max_backref;
+	/* Compilation flags. */
+	int cflags;
+} tre_parse_ctx_t;
+
+/* Some macros for expanding \w, \s, etc. */
+static const struct {
+	char c;
+	const char *expansion;
+} tre_macros[] = {
+	{'t', "\t"}, {'n', "\n"}, {'r', "\r"},
+	{'f', "\f"}, {'a', "\a"}, {'e', "\033"},
+	{'w', "[[:alnum:]_]"}, {'W', "[^[:alnum:]_]"}, {'s', "[[:space:]]"},
+	{'S', "[^[:space:]]"}, {'d', "[[:digit:]]"}, {'D', "[^[:digit:]]"},
+	{ 0, 0 }
+};
+
+/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
+   must have at least `len' items.  Sets buf[0] to zero if the there
+   is no match in `tre_macros'. */
+static const char *tre_expand_macro(const char *s)
+{
+	int i;
+	for (i = 0; tre_macros[i].c && tre_macros[i].c != *s; i++);
+	return tre_macros[i].expansion;
+}
+
+static int
+tre_compare_lit(const void *a, const void *b)
+{
+	const tre_literal_t *const *la = a;
+	const tre_literal_t *const *lb = b;
+	/* assumes the range of valid code_min is < INT_MAX */
+	return la[0]->code_min - lb[0]->code_min;
+}
+
+struct literals {
+	tre_mem_t mem;
+	tre_literal_t **a;
+	int len;
+	int cap;
+};
+
+static tre_literal_t *tre_new_lit(struct literals *p)
+{
+	tre_literal_t **a;
+	if (p->len >= p->cap) {
+		if (p->cap >= 1<<15)
+			return 0;
+		p->cap *= 2;
+		a = xrealloc(p->a, p->cap * sizeof *p->a);
+		if (!a)
+			return 0;
+		p->a = a;
+	}
+	a = p->a + p->len++;
+	*a = tre_mem_calloc(p->mem, sizeof **a);
+	return *a;
+}
+
+static int add_icase_literals(struct literals *ls, int min, int max)
+{
+	tre_literal_t *lit;
+	int b, e, c;
+	for (c=min; c<=max; ) {
+		/* assumes islower(c) and isupper(c) are exclusive
+		   and toupper(c)!=c if islower(c).
+		   multiple opposite case characters are not supported */
+		if (tre_islower(c)) {
+			b = e = tre_toupper(c);
+			for (c++, e++; c<=max; c++, e++)
+				if (tre_toupper(c) != e) break;
+		} else if (tre_isupper(c)) {
+			b = e = tre_tolower(c);
+			for (c++, e++; c<=max; c++, e++)
+				if (tre_tolower(c) != e) break;
+		} else {
+			c++;
+			continue;
+		}
+		lit = tre_new_lit(ls);
+		if (!lit)
+			return -1;
+		lit->code_min = b;
+		lit->code_max = e-1;
+		lit->position = -1;
+	}
+	return 0;
+}
+
+
+/* Maximum number of character classes in a negated bracket expression. */
+#define MAX_NEG_CLASSES 64
+
+struct neg {
+	int negate;
+	int len;
+	tre_ctype_t a[MAX_NEG_CLASSES];
+};
+
+// TODO: parse bracket into a set of non-overlapping [lo,hi] ranges
+
+/*
+bracket grammar:
+Bracket  =  '[' List ']'  |  '[^' List ']'
+List     =  Term  |  List Term
+Term     =  Char  |  Range  |  Chclass  |  Eqclass
+Range    =  Char '-' Char  |  Char '-' '-'
+Char     =  Coll  |  coll_single
+Meta     =  ']'  |  '-'
+Coll     =  '[.' coll_single '.]'  |  '[.' coll_multi '.]'  |  '[.' Meta '.]'
+Eqclass  =  '[=' coll_single '=]'  |  '[=' coll_multi '=]'
+Chclass  =  '[:' class ':]'
+
+coll_single is a single char collating element but it can be
+ '-' only at the beginning or end of a List and
+ ']' only at the beginning of a List and
+ '^' anywhere except after the openning '['
+*/
+
+static reg_errcode_t parse_bracket_terms(tre_parse_ctx_t *ctx, const char *s, struct literals *ls, struct neg *neg)
+{
+	const char *start = s;
+	tre_ctype_t class;
+	int min, max;
+	wchar_t wc;
+	int len;
+
+	for (;;) {
+		class = 0;
+		len = mbtowc(&wc, s, -1);
+		if (len <= 0)
+			return *s ? REG_BADPAT : REG_EBRACK;
+		if (*s == ']' && s != start) {
+			ctx->s = s+1;
+			return REG_OK;
+		}
+		if (*s == '-' && s != start && s[1] != ']' &&
+		    /* extension: [a-z--@] is accepted as [a-z]|[--@] */
+		    (s[1] != '-' || s[2] == ']'))
+			return REG_ERANGE;
+		if (*s == '[' && (s[1] == '.' || s[1] == '='))
+			/* collating symbols and equivalence classes are not supported */
+			return REG_ECOLLATE;
+		if (*s == '[' && s[1] == ':') {
+			char tmp[CHARCLASS_NAME_MAX+1];
+			s += 2;
+			for (len=0; len < CHARCLASS_NAME_MAX && s[len]; len++) {
+				if (s[len] == ':') {
+					memcpy(tmp, s, len);
+					tmp[len] = 0;
+					class = tre_ctype(tmp);
+					break;
+				}
+			}
+			if (!class || s[len+1] != ']')
+				return REG_ECTYPE;
+			min = 0;
+			max = TRE_CHAR_MAX;
+			s += len+2;
+		} else {
+			min = max = wc;
+			s += len;
+			if (*s == '-' && s[1] != ']') {
+				s++;
+				len = mbtowc(&wc, s, -1);
+				max = wc;
+				/* XXX - Should use collation order instead of
+				   encoding values in character ranges. */
+				if (len <= 0 || min > max)
+					return REG_ERANGE;
+				s += len;
+			}
+		}
+
+		if (class && neg->negate) {
+			if (neg->len >= MAX_NEG_CLASSES)
+				return REG_ESPACE;
+			neg->a[neg->len++] = class;
+		} else  {
+			tre_literal_t *lit = tre_new_lit(ls);
+			if (!lit)
+				return REG_ESPACE;
+			lit->code_min = min;
+			lit->code_max = max;
+			lit->class = class;
+			lit->position = -1;
+
+			/* Add opposite-case codepoints if REG_ICASE is present.
+			   It seems that POSIX requires that bracket negation
+			   should happen before case-folding, but most practical
+			   implementations do it the other way around. Changing
+			   the order would need efficient representation of
+			   case-fold ranges and bracket range sets even with
+			   simple patterns so this is ok for now. */
+			if (ctx->cflags & REG_ICASE && !class)
+				if (add_icase_literals(ls, min, max))
+					return REG_ESPACE;
+		}
+	}
+}
+
+static reg_errcode_t parse_bracket(tre_parse_ctx_t *ctx, const char *s)
+{
+	int i, max, min, negmax, negmin;
+	tre_ast_node_t *node = 0, *n;
+	tre_ctype_t *nc = 0;
+	tre_literal_t *lit;
+	struct literals ls;
+	struct neg neg;
+	reg_errcode_t err;
+
+	ls.mem = ctx->mem;
+	ls.len = 0;
+	ls.cap = 32;
+	ls.a = xmalloc(ls.cap * sizeof *ls.a);
+	if (!ls.a)
+		return REG_ESPACE;
+	neg.len = 0;
+	neg.negate = *s == '^';
+	if (neg.negate)
+		s++;
+
+	err = parse_bracket_terms(ctx, s, &ls, &neg);
+	if (err != REG_OK)
+		goto parse_bracket_done;
+
+	if (neg.negate) {
+		/*
+		 * With REG_NEWLINE, POSIX requires that newlines are not matched by
+		 * any form of a non-matching list.
+		 */
+		if (ctx->cflags & REG_NEWLINE) {
+			lit = tre_new_lit(&ls);
+			if (!lit) {
+				err = REG_ESPACE;
+				goto parse_bracket_done;
+			}
+			lit->code_min = '\n';
+			lit->code_max = '\n';
+			lit->position = -1;
+		}
+		/* Sort the array if we need to negate it. */
+		qsort(ls.a, ls.len, sizeof *ls.a, tre_compare_lit);
+		/* extra lit for the last negated range */
+		lit = tre_new_lit(&ls);
+		if (!lit) {
+			err = REG_ESPACE;
+			goto parse_bracket_done;
+		}
+		lit->code_min = TRE_CHAR_MAX+1;
+		lit->code_max = TRE_CHAR_MAX+1;
+		lit->position = -1;
+		/* negated classes */
+		if (neg.len) {
+			nc = tre_mem_alloc(ctx->mem, (neg.len+1)*sizeof *neg.a);
+			if (!nc) {
+				err = REG_ESPACE;
+				goto parse_bracket_done;
+			}
+			memcpy(nc, neg.a, neg.len*sizeof *neg.a);
+			nc[neg.len] = 0;
+		}
+	}
+
+	/* Build a union of the items in the array, negated if necessary. */
+	negmax = negmin = 0;
+	for (i = 0; i < ls.len; i++) {
+		lit = ls.a[i];
+		min = lit->code_min;
+		max = lit->code_max;
+		if (neg.negate) {
+			if (min <= negmin) {
+				/* Overlap. */
+				negmin = MAX(max + 1, negmin);
+				continue;
+			}
+			negmax = min - 1;
+			lit->code_min = negmin;
+			lit->code_max = negmax;
+			negmin = max + 1;
+		}
+		lit->position = ctx->position;
+		lit->neg_classes = nc;
+		n = tre_ast_new_node(ctx->mem, LITERAL, lit);
+		node = tre_ast_new_union(ctx->mem, node, n);
+		if (!node) {
+			err = REG_ESPACE;
+			break;
+		}
+	}
+
+parse_bracket_done:
+	xfree(ls.a);
+	ctx->position++;
+	ctx->n = node;
+	return err;
+}
+
+static const char *parse_dup_count(const char *s, int *n)
+{
+	*n = -1;
+	if (!isdigit(*s))
+		return s;
+	*n = 0;
+	for (;;) {
+		*n = 10 * *n + (*s - '0');
+		s++;
+		if (!isdigit(*s) || *n > RE_DUP_MAX)
+			break;
+	}
+	return s;
+}
+
+static const char *parse_dup(const char *s, int ere, int *pmin, int *pmax)
+{
+	int min, max;
+
+	s = parse_dup_count(s, &min);
+	if (*s == ',')
+		s = parse_dup_count(s+1, &max);
+	else
+		max = min;
+
+	if (
+		(max < min && max >= 0) ||
+		max > RE_DUP_MAX ||
+		min > RE_DUP_MAX ||
+		min < 0 ||
+		(!ere && *s++ != '\\') ||
+		*s++ != '}'
+	)
+		return 0;
+	*pmin = min;
+	*pmax = max;
+	return s;
+}
+
+static int hexval(unsigned c)
+{
+	if (c-'0'<10) return c-'0';
+	c |= 32;
+	if (c-'a'<6) return c-'a'+10;
+	return -1;
+}
+
+static reg_errcode_t marksub(tre_parse_ctx_t *ctx, tre_ast_node_t *node, int subid)
+{
+	if (node->submatch_id >= 0) {
+		tre_ast_node_t *n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+		if (!n)
+			return REG_ESPACE;
+		n = tre_ast_new_catenation(ctx->mem, n, node);
+		if (!n)
+			return REG_ESPACE;
+		n->num_submatches = node->num_submatches;
+		node = n;
+	}
+	node->submatch_id = subid;
+	node->num_submatches++;
+	ctx->n = node;
+	return REG_OK;
+}
+
+/*
+BRE grammar:
+Regex  =  Branch  |  '^'  |  '$'  |  '^$'  |  '^' Branch  |  Branch '$'  |  '^' Branch '$'
+Branch =  Atom  |  Branch Atom
+Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '\(' Branch '\)'  |  back_ref
+Dup    =  '*'  |  '\{' Count '\}'  |  '\{' Count ',\}'  |  '\{' Count ',' Count '\}'
+
+(leading ^ and trailing $ in a sub expr may be an anchor or literal as well)
+
+ERE grammar:
+Regex  =  Branch  |  Regex '|' Branch
+Branch =  Atom  |  Branch Atom
+Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '(' Regex ')'  |  '^'  |  '$'
+Dup    =  '*'  |  '+'  |  '?'  |  '{' Count '}'  |  '{' Count ',}'  |  '{' Count ',' Count '}'
+
+(a*+?, ^*, $+, \X, {, (|a) are unspecified)
+*/
+
+static reg_errcode_t parse_atom(tre_parse_ctx_t *ctx, const char *s)
+{
+	int len, ere = ctx->cflags & REG_EXTENDED;
+	const char *p;
+	tre_ast_node_t *node;
+	wchar_t wc;
+	switch (*s) {
+	case '[':
+		return parse_bracket(ctx, s+1);
+	case '\\':
+		p = tre_expand_macro(s+1);
+		if (p) {
+			/* assume \X expansion is a single atom */
+			reg_errcode_t err = parse_atom(ctx, p);
+			ctx->s = s+2;
+			return err;
+		}
+		/* extensions: \b, \B, \<, \>, \xHH \x{HHHH} */
+		switch (*++s) {
+		case 0:
+			return REG_EESCAPE;
+		case 'b':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB, -1);
+			break;
+		case 'B':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB_NEG, -1);
+			break;
+		case '<':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOW, -1);
+			break;
+		case '>':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOW, -1);
+			break;
+		case 'x':
+			s++;
+			int i, v = 0, c;
+			len = 2;
+			if (*s == '{') {
+				len = 8;
+				s++;
+			}
+			for (i=0; i<len && v<0x110000; i++) {
+				c = hexval(s[i]);
+				if (c < 0) break;
+				v = 16*v + c;
+			}
+			s += i;
+			if (len == 8) {
+				if (*s != '}')
+					return REG_EBRACE;
+				s++;
+			}
+			node = tre_ast_new_literal(ctx->mem, v, v, ctx->position++);
+			s--;
+			break;
+		case '{':
+		case '+':
+		case '?':
+			/* extension: treat \+, \? as repetitions in BRE */
+			/* reject repetitions after empty expression in BRE */
+			if (!ere)
+				return REG_BADRPT;
+		case '|':
+			/* extension: treat \| as alternation in BRE */
+			if (!ere) {
+				node = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+				s--;
+				goto end;
+			}
+			/* fallthrough */
+		default:
+			if (!ere && (unsigned)*s-'1' < 9) {
+				/* back reference */
+				int val = *s - '0';
+				node = tre_ast_new_literal(ctx->mem, BACKREF, val, ctx->position++);
+				ctx->max_backref = MAX(val, ctx->max_backref);
+			} else {
+				/* extension: accept unknown escaped char
+				   as a literal */
+				goto parse_literal;
+			}
+		}
+		s++;
+		break;
+	case '.':
+		if (ctx->cflags & REG_NEWLINE) {
+			tre_ast_node_t *tmp1, *tmp2;
+			tmp1 = tre_ast_new_literal(ctx->mem, 0, '\n'-1, ctx->position++);
+			tmp2 = tre_ast_new_literal(ctx->mem, '\n'+1, TRE_CHAR_MAX, ctx->position++);
+			if (tmp1 && tmp2)
+				node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
+			else
+				node = 0;
+		} else {
+			node = tre_ast_new_literal(ctx->mem, 0, TRE_CHAR_MAX, ctx->position++);
+		}
+		s++;
+		break;
+	case '^':
+		/* '^' has a special meaning everywhere in EREs, and at beginning of BRE. */
+		if (!ere && s != ctx->start)
+			goto parse_literal;
+		node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOL, -1);
+		s++;
+		break;
+	case '$':
+		/* '$' is special everywhere in EREs, and at the end of a BRE subexpression. */
+		if (!ere && s[1] && (s[1]!='\\'|| (s[2]!=')' && s[2]!='|')))
+			goto parse_literal;
+		node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOL, -1);
+		s++;
+		break;
+	case '*':
+	case '{':
+	case '+':
+	case '?':
+		/* reject repetitions after empty expression in ERE */
+		if (ere)
+			return REG_BADRPT;
+	case '|':
+		if (!ere)
+			goto parse_literal;
+	case 0:
+		node = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+		break;
+	default:
+parse_literal:
+		len = mbtowc(&wc, s, -1);
+		if (len < 0)
+			return REG_BADPAT;
+		if (ctx->cflags & REG_ICASE && (tre_isupper(wc) || tre_islower(wc))) {
+			tre_ast_node_t *tmp1, *tmp2;
+			/* multiple opposite case characters are not supported */
+			tmp1 = tre_ast_new_literal(ctx->mem, tre_toupper(wc), tre_toupper(wc), ctx->position);
+			tmp2 = tre_ast_new_literal(ctx->mem, tre_tolower(wc), tre_tolower(wc), ctx->position);
+			if (tmp1 && tmp2)
+				node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
+			else
+				node = 0;
+		} else {
+			node = tre_ast_new_literal(ctx->mem, wc, wc, ctx->position);
+		}
+		ctx->position++;
+		s += len;
+		break;
+	}
+end:
+	if (!node)
+		return REG_ESPACE;
+	ctx->n = node;
+	ctx->s = s;
+	return REG_OK;
+}
+
+#define PUSHPTR(err, s, v) do { \
+	if ((err = tre_stack_push_voidptr(s, v)) != REG_OK) \
+		return err; \
+} while(0)
+
+#define PUSHINT(err, s, v) do { \
+	if ((err = tre_stack_push_int(s, v)) != REG_OK) \
+		return err; \
+} while(0)
+
+static reg_errcode_t tre_parse(tre_parse_ctx_t *ctx)
+{
+	tre_ast_node_t *nbranch=0, *nunion=0;
+	int ere = ctx->cflags & REG_EXTENDED;
+	const char *s = ctx->start;
+	int subid = 0;
+	int depth = 0;
+	reg_errcode_t err;
+	tre_stack_t *stack = ctx->stack;
+
+	PUSHINT(err, stack, subid++);
+	for (;;) {
+		if ((!ere && *s == '\\' && s[1] == '(') ||
+		    (ere && *s == '(')) {
+			PUSHPTR(err, stack, nunion);
+			PUSHPTR(err, stack, nbranch);
+			PUSHINT(err, stack, subid++);
+			s++;
+			if (!ere)
+				s++;
+			depth++;
+			nbranch = nunion = 0;
+			ctx->start = s;
+			continue;
+		}
+		if ((!ere && *s == '\\' && s[1] == ')') ||
+		    (ere && *s == ')' && depth)) {
+			ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+			if (!ctx->n)
+				return REG_ESPACE;
+		} else {
+			err = parse_atom(ctx, s);
+			if (err != REG_OK)
+				return err;
+			s = ctx->s;
+		}
+
+	parse_iter:
+		for (;;) {
+			int min, max;
+
+			if (*s!='\\' && *s!='*') {
+				if (!ere)
+					break;
+				if (*s!='+' && *s!='?' && *s!='{')
+					break;
+			}
+			if (*s=='\\' && ere)
+				break;
+			/* extension: treat \+, \? as repetitions in BRE */
+			if (*s=='\\' && s[1]!='+' && s[1]!='?' && s[1]!='{')
+				break;
+			if (*s=='\\')
+				s++;
+
+			/* handle ^* at the start of a BRE. */
+			if (!ere && s==ctx->start+1 && s[-1]=='^')
+				break;
+
+			/* extension: multiple consecutive *+?{,} is unspecified,
+			   but (a+)+ has to be supported so accepting a++ makes
+			   sense, note however that the RE_DUP_MAX limit can be
+			   circumvented: (a{255}){255} uses a lot of memory.. */
+			if (*s=='{') {
+				s = parse_dup(s+1, ere, &min, &max);
+				if (!s)
+					return REG_BADBR;
+			} else {
+				min=0;
+				max=-1;
+				if (*s == '+')
+					min = 1;
+				if (*s == '?')
+					max = 1;
+				s++;
+			}
+			if (max == 0)
+				ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+			else
+				ctx->n = tre_ast_new_iter(ctx->mem, ctx->n, min, max, 0);
+			if (!ctx->n)
+				return REG_ESPACE;
+		}
+
+		nbranch = tre_ast_new_catenation(ctx->mem, nbranch, ctx->n);
+		if ((ere && *s == '|') ||
+		    (ere && *s == ')' && depth) ||
+		    (!ere && *s == '\\' && s[1] == ')') ||
+		    /* extension: treat \| as alternation in BRE */
+		    (!ere && *s == '\\' && s[1] == '|') ||
+		    !*s) {
+			/* extension: empty branch is unspecified (), (|a), (a|)
+			   here they are not rejected but match on empty string */
+			int c = *s;
+			nunion = tre_ast_new_union(ctx->mem, nunion, nbranch);
+			nbranch = 0;
+
+			if (c == '\\' && s[1] == '|') {
+				s+=2;
+				ctx->start = s;
+			} else if (c == '|') {
+				s++;
+				ctx->start = s;
+			} else {
+				if (c == '\\') {
+					if (!depth) return REG_EPAREN;
+					s+=2;
+				} else if (c == ')')
+					s++;
+				depth--;
+				err = marksub(ctx, nunion, tre_stack_pop_int(stack));
+				if (err != REG_OK)
+					return err;
+				if (!c && depth<0) {
+					ctx->submatch_id = subid;
+					return REG_OK;
+				}
+				if (!c || depth<0)
+					return REG_EPAREN;
+				nbranch = tre_stack_pop_voidptr(stack);
+				nunion = tre_stack_pop_voidptr(stack);
+				goto parse_iter;
+			}
+		}
+	}
+}
+
+
+/***********************************************************************
+ from tre-compile.c
+***********************************************************************/
+
+
+/*
+  TODO:
+   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
+     function calls.
+*/
+
+/*
+  Algorithms to setup tags so that submatch addressing can be done.
+*/
+
+
+/* Inserts a catenation node to the root of the tree given in `node'.
+   As the left child a new tag with number `tag_id' to `node' is added,
+   and the right child is the old root. */
+static reg_errcode_t
+tre_add_tag_left(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
+{
+  tre_catenation_t *c;
+
+  c = tre_mem_alloc(mem, sizeof(*c));
+  if (c == NULL)
+    return REG_ESPACE;
+  c->left = tre_ast_new_literal(mem, TAG, tag_id, -1);
+  if (c->left == NULL)
+    return REG_ESPACE;
+  c->right = tre_mem_alloc(mem, sizeof(tre_ast_node_t));
+  if (c->right == NULL)
+    return REG_ESPACE;
+
+  c->right->obj = node->obj;
+  c->right->type = node->type;
+  c->right->nullable = -1;
+  c->right->submatch_id = -1;
+  c->right->firstpos = NULL;
+  c->right->lastpos = NULL;
+  c->right->num_tags = 0;
+  c->right->num_submatches = 0;
+  node->obj = c;
+  node->type = CATENATION;
+  return REG_OK;
+}
+
+/* Inserts a catenation node to the root of the tree given in `node'.
+   As the right child a new tag with number `tag_id' to `node' is added,
+   and the left child is the old root. */
+static reg_errcode_t
+tre_add_tag_right(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
+{
+  tre_catenation_t *c;
+
+  c = tre_mem_alloc(mem, sizeof(*c));
+  if (c == NULL)
+    return REG_ESPACE;
+  c->right = tre_ast_new_literal(mem, TAG, tag_id, -1);
+  if (c->right == NULL)
+    return REG_ESPACE;
+  c->left = tre_mem_alloc(mem, sizeof(tre_ast_node_t));
+  if (c->left == NULL)
+    return REG_ESPACE;
+
+  c->left->obj = node->obj;
+  c->left->type = node->type;
+  c->left->nullable = -1;
+  c->left->submatch_id = -1;
+  c->left->firstpos = NULL;
+  c->left->lastpos = NULL;
+  c->left->num_tags = 0;
+  c->left->num_submatches = 0;
+  node->obj = c;
+  node->type = CATENATION;
+  return REG_OK;
+}
+
+typedef enum {
+  ADDTAGS_RECURSE,
+  ADDTAGS_AFTER_ITERATION,
+  ADDTAGS_AFTER_UNION_LEFT,
+  ADDTAGS_AFTER_UNION_RIGHT,
+  ADDTAGS_AFTER_CAT_LEFT,
+  ADDTAGS_AFTER_CAT_RIGHT,
+  ADDTAGS_SET_SUBMATCH_END
+} tre_addtags_symbol_t;
+
+
+typedef struct {
+  int tag;
+  int next_tag;
+} tre_tag_states_t;
+
+
+/* Go through `regset' and set submatch data for submatches that are
+   using this tag. */
+static void
+tre_purge_regset(int *regset, tre_tnfa_t *tnfa, int tag)
+{
+  int i;
+
+  for (i = 0; regset[i] >= 0; i++)
+    {
+      int id = regset[i] / 2;
+      int start = !(regset[i] % 2);
+      if (start)
+	tnfa->submatch_data[id].so_tag = tag;
+      else
+	tnfa->submatch_data[id].eo_tag = tag;
+    }
+  regset[0] = -1;
+}
+
+
+/* Adds tags to appropriate locations in the parse tree in `tree', so that
+   subexpressions marked for submatch addressing can be traced. */
+static reg_errcode_t
+tre_add_tags(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree,
+	     tre_tnfa_t *tnfa)
+{
+  reg_errcode_t status = REG_OK;
+  tre_addtags_symbol_t symbol;
+  tre_ast_node_t *node = tree; /* Tree node we are currently looking at. */
+  int bottom = tre_stack_num_objects(stack);
+  /* True for first pass (counting number of needed tags) */
+  int first_pass = (mem == NULL || tnfa == NULL);
+  int *regset, *orig_regset;
+  int num_tags = 0; /* Total number of tags. */
+  int num_minimals = 0;	 /* Number of special minimal tags. */
+  int tag = 0;	    /* The tag that is to be added next. */
+  int next_tag = 1; /* Next tag to use after this one. */
+  int *parents;	    /* Stack of submatches the current submatch is
+		       contained in. */
+  int minimal_tag = -1; /* Tag that marks the beginning of a minimal match. */
+  tre_tag_states_t *saved_states;
+
+  tre_tag_direction_t direction = TRE_TAG_MINIMIZE;
+  if (!first_pass)
+    {
+      tnfa->end_tag = 0;
+      tnfa->minimal_tags[0] = -1;
+    }
+
+  regset = xmalloc(sizeof(*regset) * ((tnfa->num_submatches + 1) * 2));
+  if (regset == NULL)
+    return REG_ESPACE;
+  regset[0] = -1;
+  orig_regset = regset;
+
+  parents = xmalloc(sizeof(*parents) * (tnfa->num_submatches + 1));
+  if (parents == NULL)
+    {
+      xfree(regset);
+      return REG_ESPACE;
+    }
+  parents[0] = -1;
+
+  saved_states = xmalloc(sizeof(*saved_states) * (tnfa->num_submatches + 1));
+  if (saved_states == NULL)
+    {
+      xfree(regset);
+      xfree(parents);
+      return REG_ESPACE;
+    }
+  else
+    {
+      unsigned int i;
+      for (i = 0; i <= tnfa->num_submatches; i++)
+	saved_states[i].tag = -1;
+    }
+
+  STACK_PUSH(stack, voidptr, node);
+  STACK_PUSH(stack, int, ADDTAGS_RECURSE);
+
+  while (tre_stack_num_objects(stack) > bottom)
+    {
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_addtags_symbol_t)tre_stack_pop_int(stack);
+      switch (symbol)
+	{
+
+	case ADDTAGS_SET_SUBMATCH_END:
+	  {
+	    int id = tre_stack_pop_int(stack);
+	    int i;
+
+	    /* Add end of this submatch to regset. */
+	    for (i = 0; regset[i] >= 0; i++);
+	    regset[i] = id * 2 + 1;
+	    regset[i + 1] = -1;
+
+	    /* Pop this submatch from the parents stack. */
+	    for (i = 0; parents[i] >= 0; i++);
+	    parents[i - 1] = -1;
+	    break;
+	  }
+
+	case ADDTAGS_RECURSE:
+	  node = tre_stack_pop_voidptr(stack);
+
+	  if (node->submatch_id >= 0)
+	    {
+	      int id = node->submatch_id;
+	      int i;
+
+
+	      /* Add start of this submatch to regset. */
+	      for (i = 0; regset[i] >= 0; i++);
+	      regset[i] = id * 2;
+	      regset[i + 1] = -1;
+
+	      if (!first_pass)
+		{
+		  for (i = 0; parents[i] >= 0; i++);
+		  tnfa->submatch_data[id].parents = NULL;
+		  if (i > 0)
+		    {
+		      int *p = xmalloc(sizeof(*p) * (i + 1));
+		      if (p == NULL)
+			{
+			  status = REG_ESPACE;
+			  break;
+			}
+		      assert(tnfa->submatch_data[id].parents == NULL);
+		      tnfa->submatch_data[id].parents = p;
+		      for (i = 0; parents[i] >= 0; i++)
+			p[i] = parents[i];
+		      p[i] = -1;
+		    }
+		}
+
+	      /* Add end of this submatch to regset after processing this
+		 node. */
+	      STACK_PUSHX(stack, int, node->submatch_id);
+	      STACK_PUSHX(stack, int, ADDTAGS_SET_SUBMATCH_END);
+	    }
+
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = node->obj;
+
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    int i;
+		    if (regset[0] >= 0)
+		      {
+			/* Regset is not empty, so add a tag before the
+			   literal or backref. */
+			if (!first_pass)
+			  {
+			    status = tre_add_tag_left(mem, node, tag);
+			    tnfa->tag_directions[tag] = direction;
+			    if (minimal_tag >= 0)
+			      {
+				for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+				tnfa->minimal_tags[i] = tag;
+				tnfa->minimal_tags[i + 1] = minimal_tag;
+				tnfa->minimal_tags[i + 2] = -1;
+				minimal_tag = -1;
+				num_minimals++;
+			      }
+			    tre_purge_regset(regset, tnfa, tag);
+			  }
+			else
+			  {
+			    node->num_tags = 1;
+			  }
+
+			regset[0] = -1;
+			tag = next_tag;
+			num_tags++;
+			next_tag++;
+		      }
+		  }
+		else
+		  {
+		    assert(!IS_TAG(lit));
+		  }
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		tre_ast_node_t *left = cat->left;
+		tre_ast_node_t *right = cat->right;
+		int reserved_tag = -1;
+
+
+		/* After processing right child. */
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_RIGHT);
+
+		/* Process right child. */
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* After processing left child. */
+		STACK_PUSHX(stack, int, next_tag + left->num_tags);
+		if (left->num_tags > 0 && right->num_tags > 0)
+		  {
+		    /* Reserve the next tag to the right child. */
+		    reserved_tag = next_tag;
+		    next_tag++;
+		  }
+		STACK_PUSHX(stack, int, reserved_tag);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_LEFT);
+
+		/* Process left child. */
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		}
+	      break;
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+
+		if (first_pass)
+		  {
+		    STACK_PUSHX(stack, int, regset[0] >= 0 || iter->minimal);
+		  }
+		else
+		  {
+		    STACK_PUSHX(stack, int, tag);
+		    STACK_PUSHX(stack, int, iter->minimal);
+		  }
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_ITERATION);
+
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* Regset is not empty, so add a tag here. */
+		if (regset[0] >= 0 || iter->minimal)
+		  {
+		    if (!first_pass)
+		      {
+			int i;
+			status = tre_add_tag_left(mem, node, tag);
+			if (iter->minimal)
+			  tnfa->tag_directions[tag] = TRE_TAG_MAXIMIZE;
+			else
+			  tnfa->tag_directions[tag] = direction;
+			if (minimal_tag >= 0)
+			  {
+			    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+			    tnfa->minimal_tags[i] = tag;
+			    tnfa->minimal_tags[i + 1] = minimal_tag;
+			    tnfa->minimal_tags[i + 2] = -1;
+			    minimal_tag = -1;
+			    num_minimals++;
+			  }
+			tre_purge_regset(regset, tnfa, tag);
+		      }
+
+		    regset[0] = -1;
+		    tag = next_tag;
+		    num_tags++;
+		    next_tag++;
+		  }
+		direction = TRE_TAG_MINIMIZE;
+	      }
+	      break;
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		tre_ast_node_t *left = uni->left;
+		tre_ast_node_t *right = uni->right;
+		int left_tag;
+		int right_tag;
+
+		if (regset[0] >= 0)
+		  {
+		    left_tag = next_tag;
+		    right_tag = next_tag + 1;
+		  }
+		else
+		  {
+		    left_tag = tag;
+		    right_tag = next_tag;
+		  }
+
+		/* After processing right child. */
+		STACK_PUSHX(stack, int, right_tag);
+		STACK_PUSHX(stack, int, left_tag);
+		STACK_PUSHX(stack, voidptr, regset);
+		STACK_PUSHX(stack, int, regset[0] >= 0);
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_RIGHT);
+
+		/* Process right child. */
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* After processing left child. */
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_LEFT);
+
+		/* Process left child. */
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* Regset is not empty, so add a tag here. */
+		if (regset[0] >= 0)
+		  {
+		    if (!first_pass)
+		      {
+			int i;
+			status = tre_add_tag_left(mem, node, tag);
+			tnfa->tag_directions[tag] = direction;
+			if (minimal_tag >= 0)
+			  {
+			    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+			    tnfa->minimal_tags[i] = tag;
+			    tnfa->minimal_tags[i + 1] = minimal_tag;
+			    tnfa->minimal_tags[i + 2] = -1;
+			    minimal_tag = -1;
+			    num_minimals++;
+			  }
+			tre_purge_regset(regset, tnfa, tag);
+		      }
+
+		    regset[0] = -1;
+		    tag = next_tag;
+		    num_tags++;
+		    next_tag++;
+		  }
+
+		if (node->num_submatches > 0)
+		  {
+		    /* The next two tags are reserved for markers. */
+		    next_tag++;
+		    tag = next_tag;
+		    next_tag++;
+		  }
+
+		break;
+	      }
+	    }
+
+	  if (node->submatch_id >= 0)
+	    {
+	      int i;
+	      /* Push this submatch on the parents stack. */
+	      for (i = 0; parents[i] >= 0; i++);
+	      parents[i] = node->submatch_id;
+	      parents[i + 1] = -1;
+	    }
+
+	  break; /* end case: ADDTAGS_RECURSE */
+
+	case ADDTAGS_AFTER_ITERATION:
+	  {
+	    int minimal = 0;
+	    int enter_tag;
+	    node = tre_stack_pop_voidptr(stack);
+	    if (first_pass)
+	      {
+		node->num_tags = ((tre_iteration_t *)node->obj)->arg->num_tags
+		  + tre_stack_pop_int(stack);
+		minimal_tag = -1;
+	      }
+	    else
+	      {
+		minimal = tre_stack_pop_int(stack);
+		enter_tag = tre_stack_pop_int(stack);
+		if (minimal)
+		  minimal_tag = enter_tag;
+	      }
+
+	    if (!first_pass)
+	      {
+		if (minimal)
+		  direction = TRE_TAG_MINIMIZE;
+		else
+		  direction = TRE_TAG_MAXIMIZE;
+	      }
+	    break;
+	  }
+
+	case ADDTAGS_AFTER_CAT_LEFT:
+	  {
+	    int new_tag = tre_stack_pop_int(stack);
+	    next_tag = tre_stack_pop_int(stack);
+	    if (new_tag >= 0)
+	      {
+		tag = new_tag;
+	      }
+	    break;
+	  }
+
+	case ADDTAGS_AFTER_CAT_RIGHT:
+	  node = tre_stack_pop_voidptr(stack);
+	  if (first_pass)
+	    node->num_tags = ((tre_catenation_t *)node->obj)->left->num_tags
+	      + ((tre_catenation_t *)node->obj)->right->num_tags;
+	  break;
+
+	case ADDTAGS_AFTER_UNION_LEFT:
+	  /* Lift the bottom of the `regset' array so that when processing
+	     the right operand the items currently in the array are
+	     invisible.	 The original bottom was saved at ADDTAGS_UNION and
+	     will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
+	  while (*regset >= 0)
+	    regset++;
+	  break;
+
+	case ADDTAGS_AFTER_UNION_RIGHT:
+	  {
+	    int added_tags, tag_left, tag_right;
+	    tre_ast_node_t *left = tre_stack_pop_voidptr(stack);
+	    tre_ast_node_t *right = tre_stack_pop_voidptr(stack);
+	    node = tre_stack_pop_voidptr(stack);
+	    added_tags = tre_stack_pop_int(stack);
+	    if (first_pass)
+	      {
+		node->num_tags = ((tre_union_t *)node->obj)->left->num_tags
+		  + ((tre_union_t *)node->obj)->right->num_tags + added_tags
+		  + ((node->num_submatches > 0) ? 2 : 0);
+	      }
+	    regset = tre_stack_pop_voidptr(stack);
+	    tag_left = tre_stack_pop_int(stack);
+	    tag_right = tre_stack_pop_int(stack);
+
+	    /* Add tags after both children, the left child gets a smaller
+	       tag than the right child.  This guarantees that we prefer
+	       the left child over the right child. */
+	    /* XXX - This is not always necessary (if the children have
+	       tags which must be seen for every match of that child). */
+	    /* XXX - Check if this is the only place where tre_add_tag_right
+	       is used.	 If so, use tre_add_tag_left (putting the tag before
+	       the child as opposed after the child) and throw away
+	       tre_add_tag_right. */
+	    if (node->num_submatches > 0)
+	      {
+		if (!first_pass)
+		  {
+		    status = tre_add_tag_right(mem, left, tag_left);
+		    tnfa->tag_directions[tag_left] = TRE_TAG_MAXIMIZE;
+		    if (status == REG_OK)
+		      status = tre_add_tag_right(mem, right, tag_right);
+		    tnfa->tag_directions[tag_right] = TRE_TAG_MAXIMIZE;
+		  }
+		num_tags += 2;
+	      }
+	    direction = TRE_TAG_MAXIMIZE;
+	    break;
+	  }
+
+	default:
+	  assert(0);
+	  break;
+
+	} /* end switch(symbol) */
+    } /* end while(tre_stack_num_objects(stack) > bottom) */
+
+  if (!first_pass)
+    tre_purge_regset(regset, tnfa, tag);
+
+  if (!first_pass && minimal_tag >= 0)
+    {
+      int i;
+      for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+      tnfa->minimal_tags[i] = tag;
+      tnfa->minimal_tags[i + 1] = minimal_tag;
+      tnfa->minimal_tags[i + 2] = -1;
+      minimal_tag = -1;
+      num_minimals++;
+    }
+
+  assert(tree->num_tags == num_tags);
+  tnfa->end_tag = num_tags;
+  tnfa->num_tags = num_tags;
+  tnfa->num_minimals = num_minimals;
+  xfree(orig_regset);
+  xfree(parents);
+  xfree(saved_states);
+  return status;
+}
+
+
+
+/*
+  AST to TNFA compilation routines.
+*/
+
+typedef enum {
+  COPY_RECURSE,
+  COPY_SET_RESULT_PTR
+} tre_copyast_symbol_t;
+
+/* Flags for tre_copy_ast(). */
+#define COPY_REMOVE_TAGS	 1
+#define COPY_MAXIMIZE_FIRST_TAG	 2
+
+static reg_errcode_t
+tre_copy_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
+	     int flags, int *pos_add, tre_tag_direction_t *tag_directions,
+	     tre_ast_node_t **copy, int *max_pos)
+{
+  reg_errcode_t status = REG_OK;
+  int bottom = tre_stack_num_objects(stack);
+  int num_copied = 0;
+  int first_tag = 1;
+  tre_ast_node_t **result = copy;
+  tre_copyast_symbol_t symbol;
+
+  STACK_PUSH(stack, voidptr, ast);
+  STACK_PUSH(stack, int, COPY_RECURSE);
+
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      tre_ast_node_t *node;
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_copyast_symbol_t)tre_stack_pop_int(stack);
+      switch (symbol)
+	{
+	case COPY_SET_RESULT_PTR:
+	  result = tre_stack_pop_voidptr(stack);
+	  break;
+	case COPY_RECURSE:
+	  node = tre_stack_pop_voidptr(stack);
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = node->obj;
+		int pos = lit->position;
+		int min = lit->code_min;
+		int max = lit->code_max;
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    /* XXX - e.g. [ab] has only one position but two
+		       nodes, so we are creating holes in the state space
+		       here.  Not fatal, just wastes memory. */
+		    pos += *pos_add;
+		    num_copied++;
+		  }
+		else if (IS_TAG(lit) && (flags & COPY_REMOVE_TAGS))
+		  {
+		    /* Change this tag to empty. */
+		    min = EMPTY;
+		    max = pos = -1;
+		  }
+		else if (IS_TAG(lit) && (flags & COPY_MAXIMIZE_FIRST_TAG)
+			 && first_tag)
+		  {
+		    /* Maximize the first tag. */
+		    tag_directions[max] = TRE_TAG_MAXIMIZE;
+		    first_tag = 0;
+		  }
+		*result = tre_ast_new_literal(mem, min, max, pos);
+		if (*result == NULL)
+		  status = REG_ESPACE;
+		else {
+		  tre_literal_t *p = (*result)->obj;
+		  p->class = lit->class;
+		  p->neg_classes = lit->neg_classes;
+		}
+
+		if (pos > *max_pos)
+		  *max_pos = pos;
+		break;
+	      }
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		tre_union_t *tmp;
+		*result = tre_ast_new_union(mem, uni->left, uni->right);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		tmp = (*result)->obj;
+		result = &tmp->left;
+		STACK_PUSHX(stack, voidptr, uni->right);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		STACK_PUSHX(stack, voidptr, &tmp->right);
+		STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
+		STACK_PUSHX(stack, voidptr, uni->left);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		tre_catenation_t *tmp;
+		*result = tre_ast_new_catenation(mem, cat->left, cat->right);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		tmp = (*result)->obj;
+		tmp->left = NULL;
+		tmp->right = NULL;
+		result = &tmp->left;
+
+		STACK_PUSHX(stack, voidptr, cat->right);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		STACK_PUSHX(stack, voidptr, &tmp->right);
+		STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
+		STACK_PUSHX(stack, voidptr, cat->left);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		break;
+	      }
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		*result = tre_ast_new_iter(mem, iter->arg, iter->min,
+					   iter->max, iter->minimal);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		iter = (*result)->obj;
+		result = &iter->arg;
+		break;
+	      }
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+	}
+    }
+  *pos_add += num_copied;
+  return status;
+}
+
+typedef enum {
+  EXPAND_RECURSE,
+  EXPAND_AFTER_ITER
+} tre_expand_ast_symbol_t;
+
+/* Expands each iteration node that has a finite nonzero minimum or maximum
+   iteration count to a catenated sequence of copies of the node. */
+static reg_errcode_t
+tre_expand_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
+	       int *position, tre_tag_direction_t *tag_directions)
+{
+  reg_errcode_t status = REG_OK;
+  int bottom = tre_stack_num_objects(stack);
+  int pos_add = 0;
+  int pos_add_total = 0;
+  int max_pos = 0;
+  int iter_depth = 0;
+
+  STACK_PUSHR(stack, voidptr, ast);
+  STACK_PUSHR(stack, int, EXPAND_RECURSE);
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      tre_ast_node_t *node;
+      tre_expand_ast_symbol_t symbol;
+
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_expand_ast_symbol_t)tre_stack_pop_int(stack);
+      node = tre_stack_pop_voidptr(stack);
+      switch (symbol)
+	{
+	case EXPAND_RECURSE:
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit= node->obj;
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    lit->position += pos_add;
+		    if (lit->position > max_pos)
+		      max_pos = lit->position;
+		  }
+		break;
+	      }
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		STACK_PUSHX(stack, voidptr, uni->right);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		STACK_PUSHX(stack, voidptr, uni->left);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		STACK_PUSHX(stack, voidptr, cat->right);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		STACK_PUSHX(stack, voidptr, cat->left);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		break;
+	      }
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+		STACK_PUSHX(stack, int, pos_add);
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, EXPAND_AFTER_ITER);
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		/* If we are going to expand this node at EXPAND_AFTER_ITER
+		   then don't increase the `pos' fields of the nodes now, it
+		   will get done when expanding. */
+		if (iter->min > 1 || iter->max > 1)
+		  pos_add = 0;
+		iter_depth++;
+		break;
+	      }
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+	case EXPAND_AFTER_ITER:
+	  {
+	    tre_iteration_t *iter = node->obj;
+	    int pos_add_last;
+	    pos_add = tre_stack_pop_int(stack);
+	    pos_add_last = pos_add;
+	    if (iter->min > 1 || iter->max > 1)
+	      {
+		tre_ast_node_t *seq1 = NULL, *seq2 = NULL;
+		int j;
+		int pos_add_save = pos_add;
+
+		/* Create a catenated sequence of copies of the node. */
+		for (j = 0; j < iter->min; j++)
+		  {
+		    tre_ast_node_t *copy;
+		    /* Remove tags from all but the last copy. */
+		    int flags = ((j + 1 < iter->min)
+				 ? COPY_REMOVE_TAGS
+				 : COPY_MAXIMIZE_FIRST_TAG);
+		    pos_add_save = pos_add;
+		    status = tre_copy_ast(mem, stack, iter->arg, flags,
+					  &pos_add, tag_directions, &copy,
+					  &max_pos);
+		    if (status != REG_OK)
+		      return status;
+		    if (seq1 != NULL)
+		      seq1 = tre_ast_new_catenation(mem, seq1, copy);
+		    else
+		      seq1 = copy;
+		    if (seq1 == NULL)
+		      return REG_ESPACE;
+		  }
+
+		if (iter->max == -1)
+		  {
+		    /* No upper limit. */
+		    pos_add_save = pos_add;
+		    status = tre_copy_ast(mem, stack, iter->arg, 0,
+					  &pos_add, NULL, &seq2, &max_pos);
+		    if (status != REG_OK)
+		      return status;
+		    seq2 = tre_ast_new_iter(mem, seq2, 0, -1, 0);
+		    if (seq2 == NULL)
+		      return REG_ESPACE;
+		  }
+		else
+		  {
+		    for (j = iter->min; j < iter->max; j++)
+		      {
+			tre_ast_node_t *tmp, *copy;
+			pos_add_save = pos_add;
+			status = tre_copy_ast(mem, stack, iter->arg, 0,
+					      &pos_add, NULL, &copy, &max_pos);
+			if (status != REG_OK)
+			  return status;
+			if (seq2 != NULL)
+			  seq2 = tre_ast_new_catenation(mem, copy, seq2);
+			else
+			  seq2 = copy;
+			if (seq2 == NULL)
+			  return REG_ESPACE;
+			tmp = tre_ast_new_literal(mem, EMPTY, -1, -1);
+			if (tmp == NULL)
+			  return REG_ESPACE;
+			seq2 = tre_ast_new_union(mem, tmp, seq2);
+			if (seq2 == NULL)
+			  return REG_ESPACE;
+		      }
+		  }
+
+		pos_add = pos_add_save;
+		if (seq1 == NULL)
+		  seq1 = seq2;
+		else if (seq2 != NULL)
+		  seq1 = tre_ast_new_catenation(mem, seq1, seq2);
+		if (seq1 == NULL)
+		  return REG_ESPACE;
+		node->obj = seq1->obj;
+		node->type = seq1->type;
+	      }
+
+	    iter_depth--;
+	    pos_add_total += pos_add - pos_add_last;
+	    if (iter_depth == 0)
+	      pos_add = pos_add_total;
+
+	    break;
+	  }
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  *position += pos_add_total;
+
+  /* `max_pos' should never be larger than `*position' if the above
+     code works, but just an extra safeguard let's make sure
+     `*position' is set large enough so enough memory will be
+     allocated for the transition table. */
+  if (max_pos > *position)
+    *position = max_pos;
+
+  return status;
+}
+
+static tre_pos_and_tags_t *
+tre_set_empty(tre_mem_t mem)
+{
+  tre_pos_and_tags_t *new_set;
+
+  new_set = tre_mem_calloc(mem, sizeof(*new_set));
+  if (new_set == NULL)
+    return NULL;
+
+  new_set[0].position = -1;
+  new_set[0].code_min = -1;
+  new_set[0].code_max = -1;
+
+  return new_set;
+}
+
+static tre_pos_and_tags_t *
+tre_set_one(tre_mem_t mem, int position, int code_min, int code_max,
+	    tre_ctype_t class, tre_ctype_t *neg_classes, int backref)
+{
+  tre_pos_and_tags_t *new_set;
+
+  new_set = tre_mem_calloc(mem, sizeof(*new_set) * 2);
+  if (new_set == NULL)
+    return NULL;
+
+  new_set[0].position = position;
+  new_set[0].code_min = code_min;
+  new_set[0].code_max = code_max;
+  new_set[0].class = class;
+  new_set[0].neg_classes = neg_classes;
+  new_set[0].backref = backref;
+  new_set[1].position = -1;
+  new_set[1].code_min = -1;
+  new_set[1].code_max = -1;
+
+  return new_set;
+}
+
+static tre_pos_and_tags_t *
+tre_set_union(tre_mem_t mem, tre_pos_and_tags_t *set1, tre_pos_and_tags_t *set2,
+	      int *tags, int assertions)
+{
+  int s1, s2, i, j;
+  tre_pos_and_tags_t *new_set;
+  int *new_tags;
+  int num_tags;
+
+  for (num_tags = 0; tags != NULL && tags[num_tags] >= 0; num_tags++);
+  for (s1 = 0; set1[s1].position >= 0; s1++);
+  for (s2 = 0; set2[s2].position >= 0; s2++);
+  new_set = tre_mem_calloc(mem, sizeof(*new_set) * (s1 + s2 + 1));
+  if (!new_set )
+    return NULL;
+
+  for (s1 = 0; set1[s1].position >= 0; s1++)
+    {
+      new_set[s1].position = set1[s1].position;
+      new_set[s1].code_min = set1[s1].code_min;
+      new_set[s1].code_max = set1[s1].code_max;
+      new_set[s1].assertions = set1[s1].assertions | assertions;
+      new_set[s1].class = set1[s1].class;
+      new_set[s1].neg_classes = set1[s1].neg_classes;
+      new_set[s1].backref = set1[s1].backref;
+      if (set1[s1].tags == NULL && tags == NULL)
+	new_set[s1].tags = NULL;
+      else
+	{
+	  for (i = 0; set1[s1].tags != NULL && set1[s1].tags[i] >= 0; i++);
+	  new_tags = tre_mem_alloc(mem, (sizeof(*new_tags)
+					 * (i + num_tags + 1)));
+	  if (new_tags == NULL)
+	    return NULL;
+	  for (j = 0; j < i; j++)
+	    new_tags[j] = set1[s1].tags[j];
+	  for (i = 0; i < num_tags; i++)
+	    new_tags[j + i] = tags[i];
+	  new_tags[j + i] = -1;
+	  new_set[s1].tags = new_tags;
+	}
+    }
+
+  for (s2 = 0; set2[s2].position >= 0; s2++)
+    {
+      new_set[s1 + s2].position = set2[s2].position;
+      new_set[s1 + s2].code_min = set2[s2].code_min;
+      new_set[s1 + s2].code_max = set2[s2].code_max;
+      /* XXX - why not | assertions here as well? */
+      new_set[s1 + s2].assertions = set2[s2].assertions;
+      new_set[s1 + s2].class = set2[s2].class;
+      new_set[s1 + s2].neg_classes = set2[s2].neg_classes;
+      new_set[s1 + s2].backref = set2[s2].backref;
+      if (set2[s2].tags == NULL)
+	new_set[s1 + s2].tags = NULL;
+      else
+	{
+	  for (i = 0; set2[s2].tags[i] >= 0; i++);
+	  new_tags = tre_mem_alloc(mem, sizeof(*new_tags) * (i + 1));
+	  if (new_tags == NULL)
+	    return NULL;
+	  for (j = 0; j < i; j++)
+	    new_tags[j] = set2[s2].tags[j];
+	  new_tags[j] = -1;
+	  new_set[s1 + s2].tags = new_tags;
+	}
+    }
+  new_set[s1 + s2].position = -1;
+  return new_set;
+}
+
+/* Finds the empty path through `node' which is the one that should be
+   taken according to POSIX.2 rules, and adds the tags on that path to
+   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
+   set to the number of tags seen on the path. */
+static reg_errcode_t
+tre_match_empty(tre_stack_t *stack, tre_ast_node_t *node, int *tags,
+		int *assertions, int *num_tags_seen)
+{
+  tre_literal_t *lit;
+  tre_union_t *uni;
+  tre_catenation_t *cat;
+  tre_iteration_t *iter;
+  int i;
+  int bottom = tre_stack_num_objects(stack);
+  reg_errcode_t status = REG_OK;
+  if (num_tags_seen)
+    *num_tags_seen = 0;
+
+  status = tre_stack_push_voidptr(stack, node);
+
+  /* Walk through the tree recursively. */
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      node = tre_stack_pop_voidptr(stack);
+
+      switch (node->type)
+	{
+	case LITERAL:
+	  lit = (tre_literal_t *)node->obj;
+	  switch (lit->code_min)
+	    {
+	    case TAG:
+	      if (lit->code_max >= 0)
+		{
+		  if (tags != NULL)
+		    {
+		      /* Add the tag to `tags'. */
+		      for (i = 0; tags[i] >= 0; i++)
+			if (tags[i] == lit->code_max)
+			  break;
+		      if (tags[i] < 0)
+			{
+			  tags[i] = lit->code_max;
+			  tags[i + 1] = -1;
+			}
+		    }
+		  if (num_tags_seen)
+		    (*num_tags_seen)++;
+		}
+	      break;
+	    case ASSERTION:
+	      assert(lit->code_max >= 1
+		     || lit->code_max <= ASSERT_LAST);
+	      if (assertions != NULL)
+		*assertions |= lit->code_max;
+	      break;
+	    case EMPTY:
+	      break;
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+
+	case UNION:
+	  /* Subexpressions starting earlier take priority over ones
+	     starting later, so we prefer the left subexpression over the
+	     right subexpression. */
+	  uni = (tre_union_t *)node->obj;
+	  if (uni->left->nullable)
+	    STACK_PUSHX(stack, voidptr, uni->left)
+	  else if (uni->right->nullable)
+	    STACK_PUSHX(stack, voidptr, uni->right)
+	  else
+	    assert(0);
+	  break;
+
+	case CATENATION:
+	  /* The path must go through both children. */
+	  cat = (tre_catenation_t *)node->obj;
+	  assert(cat->left->nullable);
+	  assert(cat->right->nullable);
+	  STACK_PUSHX(stack, voidptr, cat->left);
+	  STACK_PUSHX(stack, voidptr, cat->right);
+	  break;
+
+	case ITERATION:
+	  /* A match with an empty string is preferred over no match at
+	     all, so we go through the argument if possible. */
+	  iter = (tre_iteration_t *)node->obj;
+	  if (iter->arg->nullable)
+	    STACK_PUSHX(stack, voidptr, iter->arg);
+	  break;
+
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  return status;
+}
+
+
+typedef enum {
+  NFL_RECURSE,
+  NFL_POST_UNION,
+  NFL_POST_CATENATION,
+  NFL_POST_ITERATION
+} tre_nfl_stack_symbol_t;
+
+
+/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
+   the nodes of the AST `tree'. */
+static reg_errcode_t
+tre_compute_nfl(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree)
+{
+  int bottom = tre_stack_num_objects(stack);
+
+  STACK_PUSHR(stack, voidptr, tree);
+  STACK_PUSHR(stack, int, NFL_RECURSE);
+
+  while (tre_stack_num_objects(stack) > bottom)
+    {
+      tre_nfl_stack_symbol_t symbol;
+      tre_ast_node_t *node;
+
+      symbol = (tre_nfl_stack_symbol_t)tre_stack_pop_int(stack);
+      node = tre_stack_pop_voidptr(stack);
+      switch (symbol)
+	{
+	case NFL_RECURSE:
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = (tre_literal_t *)node->obj;
+		if (IS_BACKREF(lit))
+		  {
+		    /* Back references: nullable = false, firstpos = {i},
+		       lastpos = {i}. */
+		    node->nullable = 0;
+		    node->firstpos = tre_set_one(mem, lit->position, 0,
+					     TRE_CHAR_MAX, 0, NULL, -1);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_one(mem, lit->position, 0,
+						TRE_CHAR_MAX, 0, NULL,
+						(int)lit->code_max);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		else if (lit->code_min < 0)
+		  {
+		    /* Tags, empty strings, params, and zero width assertions:
+		       nullable = true, firstpos = {}, and lastpos = {}. */
+		    node->nullable = 1;
+		    node->firstpos = tre_set_empty(mem);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_empty(mem);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		else
+		  {
+		    /* Literal at position i: nullable = false, firstpos = {i},
+		       lastpos = {i}. */
+		    node->nullable = 0;
+		    node->firstpos =
+		      tre_set_one(mem, lit->position, (int)lit->code_min,
+				  (int)lit->code_max, 0, NULL, -1);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_one(mem, lit->position,
+						(int)lit->code_min,
+						(int)lit->code_max,
+						lit->class, lit->neg_classes,
+						-1);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		break;
+	      }
+
+	    case UNION:
+	      /* Compute the attributes for the two subtrees, and after that
+		 for this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_UNION);
+	      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->right);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->left);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+
+	    case CATENATION:
+	      /* Compute the attributes for the two subtrees, and after that
+		 for this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_CATENATION);
+	      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->right);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->left);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+
+	    case ITERATION:
+	      /* Compute the attributes for the subtree, and after that for
+		 this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_ITERATION);
+	      STACK_PUSHR(stack, voidptr, ((tre_iteration_t *)node->obj)->arg);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+	    }
+	  break; /* end case: NFL_RECURSE */
+
+	case NFL_POST_UNION:
+	  {
+	    tre_union_t *uni = (tre_union_t *)node->obj;
+	    node->nullable = uni->left->nullable || uni->right->nullable;
+	    node->firstpos = tre_set_union(mem, uni->left->firstpos,
+					   uni->right->firstpos, NULL, 0);
+	    if (!node->firstpos)
+	      return REG_ESPACE;
+	    node->lastpos = tre_set_union(mem, uni->left->lastpos,
+					  uni->right->lastpos, NULL, 0);
+	    if (!node->lastpos)
+	      return REG_ESPACE;
+	    break;
+	  }
+
+	case NFL_POST_ITERATION:
+	  {
+	    tre_iteration_t *iter = (tre_iteration_t *)node->obj;
+
+	    if (iter->min == 0 || iter->arg->nullable)
+	      node->nullable = 1;
+	    else
+	      node->nullable = 0;
+	    node->firstpos = iter->arg->firstpos;
+	    node->lastpos = iter->arg->lastpos;
+	    break;
+	  }
+
+	case NFL_POST_CATENATION:
+	  {
+	    int num_tags, *tags, assertions;
+	    reg_errcode_t status;
+	    tre_catenation_t *cat = node->obj;
+	    node->nullable = cat->left->nullable && cat->right->nullable;
+
+	    /* Compute firstpos. */
+	    if (cat->left->nullable)
+	      {
+		/* The left side matches the empty string.  Make a first pass
+		   with tre_match_empty() to get the number of tags and
+		   parameters. */
+		status = tre_match_empty(stack, cat->left,
+					 NULL, NULL, &num_tags);
+		if (status != REG_OK)
+		  return status;
+		/* Allocate arrays for the tags and parameters. */
+		tags = xmalloc(sizeof(*tags) * (num_tags + 1));
+		if (!tags)
+		  return REG_ESPACE;
+		tags[0] = -1;
+		assertions = 0;
+		/* Second pass with tre_mach_empty() to get the list of
+		   tags and parameters. */
+		status = tre_match_empty(stack, cat->left, tags,
+					 &assertions, NULL);
+		if (status != REG_OK)
+		  {
+		    xfree(tags);
+		    return status;
+		  }
+		node->firstpos =
+		  tre_set_union(mem, cat->right->firstpos, cat->left->firstpos,
+				tags, assertions);
+		xfree(tags);
+		if (!node->firstpos)
+		  return REG_ESPACE;
+	      }
+	    else
+	      {
+		node->firstpos = cat->left->firstpos;
+	      }
+
+	    /* Compute lastpos. */
+	    if (cat->right->nullable)
+	      {
+		/* The right side matches the empty string.  Make a first pass
+		   with tre_match_empty() to get the number of tags and
+		   parameters. */
+		status = tre_match_empty(stack, cat->right,
+					 NULL, NULL, &num_tags);
+		if (status != REG_OK)
+		  return status;
+		/* Allocate arrays for the tags and parameters. */
+		tags = xmalloc(sizeof(int) * (num_tags + 1));
+		if (!tags)
+		  return REG_ESPACE;
+		tags[0] = -1;
+		assertions = 0;
+		/* Second pass with tre_mach_empty() to get the list of
+		   tags and parameters. */
+		status = tre_match_empty(stack, cat->right, tags,
+					 &assertions, NULL);
+		if (status != REG_OK)
+		  {
+		    xfree(tags);
+		    return status;
+		  }
+		node->lastpos =
+		  tre_set_union(mem, cat->left->lastpos, cat->right->lastpos,
+				tags, assertions);
+		xfree(tags);
+		if (!node->lastpos)
+		  return REG_ESPACE;
+	      }
+	    else
+	      {
+		node->lastpos = cat->right->lastpos;
+	      }
+	    break;
+	  }
+
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  return REG_OK;
+}
+
+
+/* Adds a transition from each position in `p1' to each position in `p2'. */
+static reg_errcode_t
+tre_make_trans(tre_pos_and_tags_t *p1, tre_pos_and_tags_t *p2,
+	       tre_tnfa_transition_t *transitions,
+	       int *counts, int *offs)
+{
+  tre_pos_and_tags_t *orig_p2 = p2;
+  tre_tnfa_transition_t *trans;
+  int i, j, k, l, dup, prev_p2_pos;
+
+  if (transitions != NULL)
+    while (p1->position >= 0)
+      {
+	p2 = orig_p2;
+	prev_p2_pos = -1;
+	while (p2->position >= 0)
+	  {
+	    /* Optimization: if this position was already handled, skip it. */
+	    if (p2->position == prev_p2_pos)
+	      {
+		p2++;
+		continue;
+	      }
+	    prev_p2_pos = p2->position;
+	    /* Set `trans' to point to the next unused transition from
+	       position `p1->position'. */
+	    trans = transitions + offs[p1->position];
+	    while (trans->state != NULL)
+	      {
+#if 0
+		/* If we find a previous transition from `p1->position' to
+		   `p2->position', it is overwritten.  This can happen only
+		   if there are nested loops in the regexp, like in "((a)*)*".
+		   In POSIX.2 repetition using the outer loop is always
+		   preferred over using the inner loop.	 Therefore the
+		   transition for the inner loop is useless and can be thrown
+		   away. */
+		/* XXX - The same position is used for all nodes in a bracket
+		   expression, so this optimization cannot be used (it will
+		   break bracket expressions) unless I figure out a way to
+		   detect it here. */
+		if (trans->state_id == p2->position)
+		  {
+		    break;
+		  }
+#endif
+		trans++;
+	      }
+
+	    if (trans->state == NULL)
+	      (trans + 1)->state = NULL;
+	    /* Use the character ranges, assertions, etc. from `p1' for
+	       the transition from `p1' to `p2'. */
+	    trans->code_min = p1->code_min;
+	    trans->code_max = p1->code_max;
+	    trans->state = transitions + offs[p2->position];
+	    trans->state_id = p2->position;
+	    trans->assertions = p1->assertions | p2->assertions
+	      | (p1->class ? ASSERT_CHAR_CLASS : 0)
+	      | (p1->neg_classes != NULL ? ASSERT_CHAR_CLASS_NEG : 0);
+	    if (p1->backref >= 0)
+	      {
+		assert((trans->assertions & ASSERT_CHAR_CLASS) == 0);
+		assert(p2->backref < 0);
+		trans->u.backref = p1->backref;
+		trans->assertions |= ASSERT_BACKREF;
+	      }
+	    else
+	      trans->u.class = p1->class;
+	    if (p1->neg_classes != NULL)
+	      {
+		for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++);
+		trans->neg_classes =
+		  xmalloc(sizeof(*trans->neg_classes) * (i + 1));
+		if (trans->neg_classes == NULL)
+		  return REG_ESPACE;
+		for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++)
+		  trans->neg_classes[i] = p1->neg_classes[i];
+		trans->neg_classes[i] = (tre_ctype_t)0;
+	      }
+	    else
+	      trans->neg_classes = NULL;
+
+	    /* Find out how many tags this transition has. */
+	    i = 0;
+	    if (p1->tags != NULL)
+	      while(p1->tags[i] >= 0)
+		i++;
+	    j = 0;
+	    if (p2->tags != NULL)
+	      while(p2->tags[j] >= 0)
+		j++;
+
+	    /* If we are overwriting a transition, free the old tag array. */
+	    if (trans->tags != NULL)
+	      xfree(trans->tags);
+	    trans->tags = NULL;
+
+	    /* If there were any tags, allocate an array and fill it. */
+	    if (i + j > 0)
+	      {
+		trans->tags = xmalloc(sizeof(*trans->tags) * (i + j + 1));
+		if (!trans->tags)
+		  return REG_ESPACE;
+		i = 0;
+		if (p1->tags != NULL)
+		  while(p1->tags[i] >= 0)
+		    {
+		      trans->tags[i] = p1->tags[i];
+		      i++;
+		    }
+		l = i;
+		j = 0;
+		if (p2->tags != NULL)
+		  while (p2->tags[j] >= 0)
+		    {
+		      /* Don't add duplicates. */
+		      dup = 0;
+		      for (k = 0; k < i; k++)
+			if (trans->tags[k] == p2->tags[j])
+			  {
+			    dup = 1;
+			    break;
+			  }
+		      if (!dup)
+			trans->tags[l++] = p2->tags[j];
+		      j++;
+		    }
+		trans->tags[l] = -1;
+	      }
+
+	    p2++;
+	  }
+	p1++;
+      }
+  else
+    /* Compute a maximum limit for the number of transitions leaving
+       from each state. */
+    while (p1->position >= 0)
+      {
+	p2 = orig_p2;
+	while (p2->position >= 0)
+	  {
+	    counts[p1->position]++;
+	    p2++;
+	  }
+	p1++;
+      }
+  return REG_OK;
+}
+
+/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
+   labelled with one character range (there are no transitions on empty
+   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
+   the regexp. */
+static reg_errcode_t
+tre_ast_to_tnfa(tre_ast_node_t *node, tre_tnfa_transition_t *transitions,
+		int *counts, int *offs)
+{
+  tre_union_t *uni;
+  tre_catenation_t *cat;
+  tre_iteration_t *iter;
+  reg_errcode_t errcode = REG_OK;
+
+  /* XXX - recurse using a stack!. */
+  switch (node->type)
+    {
+    case LITERAL:
+      break;
+    case UNION:
+      uni = (tre_union_t *)node->obj;
+      errcode = tre_ast_to_tnfa(uni->left, transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(uni->right, transitions, counts, offs);
+      break;
+
+    case CATENATION:
+      cat = (tre_catenation_t *)node->obj;
+      /* Add a transition from each position in cat->left->lastpos
+	 to each position in cat->right->firstpos. */
+      errcode = tre_make_trans(cat->left->lastpos, cat->right->firstpos,
+			       transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(cat->left, transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(cat->right, transitions, counts, offs);
+      break;
+
+    case ITERATION:
+      iter = (tre_iteration_t *)node->obj;
+      assert(iter->max == -1 || iter->max == 1);
+
+      if (iter->max == -1)
+	{
+	  assert(iter->min == 0 || iter->min == 1);
+	  /* Add a transition from each last position in the iterated
+	     expression to each first position. */
+	  errcode = tre_make_trans(iter->arg->lastpos, iter->arg->firstpos,
+				   transitions, counts, offs);
+	  if (errcode != REG_OK)
+	    return errcode;
+	}
+      errcode = tre_ast_to_tnfa(iter->arg, transitions, counts, offs);
+      break;
+    }
+  return errcode;
+}
+
+
+#define ERROR_EXIT(err)		  \
+  do				  \
+    {				  \
+      errcode = err;		  \
+      if (/*CONSTCOND*/1)	  \
+      	goto error_exit;	  \
+    }				  \
+ while (/*CONSTCOND*/0)
+
+
+int
+regcomp(regex_t *restrict preg, const char *restrict regex, int cflags)
+{
+  tre_stack_t *stack;
+  tre_ast_node_t *tree, *tmp_ast_l, *tmp_ast_r;
+  tre_pos_and_tags_t *p;
+  int *counts = NULL, *offs = NULL;
+  int i, add = 0;
+  tre_tnfa_transition_t *transitions, *initial;
+  tre_tnfa_t *tnfa = NULL;
+  tre_submatch_data_t *submatch_data;
+  tre_tag_direction_t *tag_directions = NULL;
+  reg_errcode_t errcode;
+  tre_mem_t mem;
+
+  /* Parse context. */
+  tre_parse_ctx_t parse_ctx;
+
+  /* Allocate a stack used throughout the compilation process for various
+     purposes. */
+  stack = tre_stack_new(512, 1024000, 128);
+  if (!stack)
+    return REG_ESPACE;
+  /* Allocate a fast memory allocator. */
+  mem = tre_mem_new();
+  if (!mem)
+    {
+      tre_stack_destroy(stack);
+      return REG_ESPACE;
+    }
+
+  /* Parse the regexp. */
+  memset(&parse_ctx, 0, sizeof(parse_ctx));
+  parse_ctx.mem = mem;
+  parse_ctx.stack = stack;
+  parse_ctx.start = regex;
+  parse_ctx.cflags = cflags;
+  parse_ctx.max_backref = -1;
+  errcode = tre_parse(&parse_ctx);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+  preg->re_nsub = parse_ctx.submatch_id - 1;
+  tree = parse_ctx.n;
+
+#ifdef TRE_DEBUG
+  tre_ast_print(tree);
+#endif /* TRE_DEBUG */
+
+  /* Referring to nonexistent subexpressions is illegal. */
+  if (parse_ctx.max_backref > (int)preg->re_nsub)
+    ERROR_EXIT(REG_ESUBREG);
+
+  /* Allocate the TNFA struct. */
+  tnfa = xcalloc(1, sizeof(tre_tnfa_t));
+  if (tnfa == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->have_backrefs = parse_ctx.max_backref >= 0;
+  tnfa->have_approx = 0;
+  tnfa->num_submatches = parse_ctx.submatch_id;
+
+  /* Set up tags for submatch addressing.  If REG_NOSUB is set and the
+     regexp does not have back references, this can be skipped. */
+  if (tnfa->have_backrefs || !(cflags & REG_NOSUB))
+    {
+
+      /* Figure out how many tags we will need. */
+      errcode = tre_add_tags(NULL, stack, tree, tnfa);
+      if (errcode != REG_OK)
+	ERROR_EXIT(errcode);
+
+      if (tnfa->num_tags > 0)
+	{
+	  tag_directions = xmalloc(sizeof(*tag_directions)
+				   * (tnfa->num_tags + 1));
+	  if (tag_directions == NULL)
+	    ERROR_EXIT(REG_ESPACE);
+	  tnfa->tag_directions = tag_directions;
+	  memset(tag_directions, -1,
+		 sizeof(*tag_directions) * (tnfa->num_tags + 1));
+	}
+      tnfa->minimal_tags = xcalloc((unsigned)tnfa->num_tags * 2 + 1,
+				   sizeof(*tnfa->minimal_tags));
+      if (tnfa->minimal_tags == NULL)
+	ERROR_EXIT(REG_ESPACE);
+
+      submatch_data = xcalloc((unsigned)parse_ctx.submatch_id,
+			      sizeof(*submatch_data));
+      if (submatch_data == NULL)
+	ERROR_EXIT(REG_ESPACE);
+      tnfa->submatch_data = submatch_data;
+
+      errcode = tre_add_tags(mem, stack, tree, tnfa);
+      if (errcode != REG_OK)
+	ERROR_EXIT(errcode);
+
+    }
+
+  /* Expand iteration nodes. */
+  errcode = tre_expand_ast(mem, stack, tree, &parse_ctx.position,
+			   tag_directions);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  /* Add a dummy node for the final state.
+     XXX - For certain patterns this dummy node can be optimized away,
+	   for example "a*" or "ab*".	Figure out a simple way to detect
+	   this possibility. */
+  tmp_ast_l = tree;
+  tmp_ast_r = tre_ast_new_literal(mem, 0, 0, parse_ctx.position++);
+  if (tmp_ast_r == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  tree = tre_ast_new_catenation(mem, tmp_ast_l, tmp_ast_r);
+  if (tree == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  errcode = tre_compute_nfl(mem, stack, tree);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  counts = xmalloc(sizeof(int) * parse_ctx.position);
+  if (counts == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  offs = xmalloc(sizeof(int) * parse_ctx.position);
+  if (offs == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  for (i = 0; i < parse_ctx.position; i++)
+    counts[i] = 0;
+  tre_ast_to_tnfa(tree, NULL, counts, NULL);
+
+  add = 0;
+  for (i = 0; i < parse_ctx.position; i++)
+    {
+      offs[i] = add;
+      add += counts[i] + 1;
+      counts[i] = 0;
+    }
+  transitions = xcalloc((unsigned)add + 1, sizeof(*transitions));
+  if (transitions == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->transitions = transitions;
+  tnfa->num_transitions = add;
+
+  errcode = tre_ast_to_tnfa(tree, transitions, counts, offs);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  tnfa->firstpos_chars = NULL;
+
+  p = tree->firstpos;
+  i = 0;
+  while (p->position >= 0)
+    {
+      i++;
+      p++;
+    }
+
+  initial = xcalloc((unsigned)i + 1, sizeof(tre_tnfa_transition_t));
+  if (initial == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->initial = initial;
+
+  i = 0;
+  for (p = tree->firstpos; p->position >= 0; p++)
+    {
+      initial[i].state = transitions + offs[p->position];
+      initial[i].state_id = p->position;
+      initial[i].tags = NULL;
+      /* Copy the arrays p->tags, and p->params, they are allocated
+	 from a tre_mem object. */
+      if (p->tags)
+	{
+	  int j;
+	  for (j = 0; p->tags[j] >= 0; j++);
+	  initial[i].tags = xmalloc(sizeof(*p->tags) * (j + 1));
+	  if (!initial[i].tags)
+	    ERROR_EXIT(REG_ESPACE);
+	  memcpy(initial[i].tags, p->tags, sizeof(*p->tags) * (j + 1));
+	}
+      initial[i].assertions = p->assertions;
+      i++;
+    }
+  initial[i].state = NULL;
+
+  tnfa->num_transitions = add;
+  tnfa->final = transitions + offs[tree->lastpos[0].position];
+  tnfa->num_states = parse_ctx.position;
+  tnfa->cflags = cflags;
+
+  tre_mem_destroy(mem);
+  tre_stack_destroy(stack);
+  xfree(counts);
+  xfree(offs);
+
+  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
+  return REG_OK;
+
+ error_exit:
+  /* Free everything that was allocated and return the error code. */
+  tre_mem_destroy(mem);
+  if (stack != NULL)
+    tre_stack_destroy(stack);
+  if (counts != NULL)
+    xfree(counts);
+  if (offs != NULL)
+    xfree(offs);
+  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
+  regfree(preg);
+  return errcode;
+}
+
+
+
+
+void
+regfree(regex_t *preg)
+{
+  tre_tnfa_t *tnfa;
+  unsigned int i;
+  tre_tnfa_transition_t *trans;
+
+  tnfa = (void *)preg->TRE_REGEX_T_FIELD;
+  if (!tnfa)
+    return;
+
+  for (i = 0; i < tnfa->num_transitions; i++)
+    if (tnfa->transitions[i].state)
+      {
+	if (tnfa->transitions[i].tags)
+	  xfree(tnfa->transitions[i].tags);
+	if (tnfa->transitions[i].neg_classes)
+	  xfree(tnfa->transitions[i].neg_classes);
+      }
+  if (tnfa->transitions)
+    xfree(tnfa->transitions);
+
+  if (tnfa->initial)
+    {
+      for (trans = tnfa->initial; trans->state; trans++)
+	{
+	  if (trans->tags)
+	    xfree(trans->tags);
+	}
+      xfree(tnfa->initial);
+    }
+
+  if (tnfa->submatch_data)
+    {
+      for (i = 0; i < tnfa->num_submatches; i++)
+	if (tnfa->submatch_data[i].parents)
+	  xfree(tnfa->submatch_data[i].parents);
+      xfree(tnfa->submatch_data);
+    }
+
+  if (tnfa->tag_directions)
+    xfree(tnfa->tag_directions);
+  if (tnfa->firstpos_chars)
+    xfree(tnfa->firstpos_chars);
+  if (tnfa->minimal_tags)
+    xfree(tnfa->minimal_tags);
+  xfree(tnfa);
+}
diff --git a/options/posix/generic/regex/regerror.c b/options/posix/generic/regex/regerror.c
new file mode 100644
index 0000000..df4afa4
--- /dev/null
+++ b/options/posix/generic/regex/regerror.c
@@ -0,0 +1,35 @@
+#include <string.h>
+#include <regex.h>
+#include <stdio.h>
+
+/* Error message strings for error codes listed in `regex.h'.  This list
+   needs to be in sync with the codes listed there, naturally. */
+
+/* Converted to single string by Rich Felker to remove the need for
+ * data relocations at runtime, 27 Feb 2006. */
+
+static const char messages[] = {
+  "No error\0"
+  "No match\0"
+  "Invalid regexp\0"
+  "Unknown collating element\0"
+  "Unknown character class name\0"
+  "Trailing backslash\0"
+  "Invalid back reference\0"
+  "Missing ']'\0"
+  "Missing ')'\0"
+  "Missing '}'\0"
+  "Invalid contents of {}\0"
+  "Invalid character range\0"
+  "Out of memory\0"
+  "Repetition not preceded by valid expression\0"
+  "\0Unknown error"
+};
+
+size_t regerror(int e, const regex_t *restrict preg, char *restrict buf, size_t size)
+{
+	const char *s;
+	for (s=messages; e && *s; e--, s+=strlen(s)+1);
+	if (!*s) s++;
+	return 1+snprintf(buf, size, "%s", s);
+}
diff --git a/options/posix/generic/regex/regexec.c b/options/posix/generic/regex/regexec.c
new file mode 100644
index 0000000..8c572e7
--- /dev/null
+++ b/options/posix/generic/regex/regexec.c
@@ -0,0 +1,1026 @@
+/*
+  regexec.c - TRE POSIX compatible matching functions (and more).
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <wchar.h>
+#include <wctype.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <regex.h>
+
+#include "tre.h"
+
+#include <assert.h>
+
+static void
+tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
+		const tre_tnfa_t *tnfa, regoff_t *tags, regoff_t match_eo);
+
+/***********************************************************************
+ from tre-match-utils.h
+***********************************************************************/
+
+#define GET_NEXT_WCHAR() do {                                                 \
+    prev_c = next_c; pos += pos_add_next;                                     \
+    next_c = *str_byte;                                                       \
+    pos_add_next = 1;                                                         \
+    str_byte += pos_add_next;                                                 \
+  } while (0)
+
+#define IS_WORD_CHAR(c)	 ((c) == L'_' || tre_isalnum(c))
+
+#define CHECK_ASSERTIONS(assertions)					      \
+  (((assertions & ASSERT_AT_BOL)					      \
+    && (pos > 0 || reg_notbol)						      \
+    && (prev_c != L'\n' || !reg_newline))				      \
+   || ((assertions & ASSERT_AT_EOL)					      \
+       && (next_c != L'\0' || reg_noteol)				      \
+       && (next_c != L'\n' || !reg_newline))				      \
+   || ((assertions & ASSERT_AT_BOW)					      \
+       && (IS_WORD_CHAR(prev_c) || !IS_WORD_CHAR(next_c)))	              \
+   || ((assertions & ASSERT_AT_EOW)					      \
+       && (!IS_WORD_CHAR(prev_c) || IS_WORD_CHAR(next_c)))		      \
+   || ((assertions & ASSERT_AT_WB)					      \
+       && (pos != 0 && next_c != L'\0'					      \
+	   && IS_WORD_CHAR(prev_c) == IS_WORD_CHAR(next_c)))		      \
+   || ((assertions & ASSERT_AT_WB_NEG)					      \
+       && (pos == 0 || next_c == L'\0'					      \
+	   || IS_WORD_CHAR(prev_c) != IS_WORD_CHAR(next_c))))
+
+#define CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)                             \
+  (((trans_i->assertions & ASSERT_CHAR_CLASS)                                 \
+       && !(tnfa->cflags & REG_ICASE)                                         \
+       && !tre_isctype((tre_cint_t)prev_c, trans_i->u.class))                 \
+    || ((trans_i->assertions & ASSERT_CHAR_CLASS)                             \
+        && (tnfa->cflags & REG_ICASE)                                         \
+        && !tre_isctype(tre_tolower((tre_cint_t)prev_c),trans_i->u.class)     \
+	&& !tre_isctype(tre_toupper((tre_cint_t)prev_c),trans_i->u.class))    \
+    || ((trans_i->assertions & ASSERT_CHAR_CLASS_NEG)                         \
+        && tre_neg_char_classes_match(trans_i->neg_classes,(tre_cint_t)prev_c,\
+                                      tnfa->cflags & REG_ICASE)))
+
+
+
+
+/* Returns 1 if `t1' wins `t2', 0 otherwise. */
+static int
+tre_tag_order(int num_tags, tre_tag_direction_t *tag_directions,
+	      regoff_t *t1, regoff_t *t2)
+{
+  int i;
+  for (i = 0; i < num_tags; i++)
+    {
+      if (tag_directions[i] == TRE_TAG_MINIMIZE)
+	{
+	  if (t1[i] < t2[i])
+	    return 1;
+	  if (t1[i] > t2[i])
+	    return 0;
+	}
+      else
+	{
+	  if (t1[i] > t2[i])
+	    return 1;
+	  if (t1[i] < t2[i])
+	    return 0;
+	}
+    }
+  /*  assert(0);*/
+  return 0;
+}
+
+static int
+tre_neg_char_classes_match(tre_ctype_t *classes, tre_cint_t wc, int icase)
+{
+  while (*classes != (tre_ctype_t)0)
+    if ((!icase && tre_isctype(wc, *classes))
+	|| (icase && (tre_isctype(tre_toupper(wc), *classes)
+		      || tre_isctype(tre_tolower(wc), *classes))))
+      return 1; /* Match. */
+    else
+      classes++;
+  return 0; /* No match. */
+}
+
+
+/***********************************************************************
+ from tre-match-parallel.c
+***********************************************************************/
+
+/*
+  This algorithm searches for matches basically by reading characters
+  in the searched string one by one, starting at the beginning.	 All
+  matching paths in the TNFA are traversed in parallel.	 When two or
+  more paths reach the same state, exactly one is chosen according to
+  tag ordering rules; if returning submatches is not required it does
+  not matter which path is chosen.
+
+  The worst case time required for finding the leftmost and longest
+  match, or determining that there is no match, is always linearly
+  dependent on the length of the text being searched.
+
+  This algorithm cannot handle TNFAs with back referencing nodes.
+  See `tre-match-backtrack.c'.
+*/
+
+typedef struct {
+  tre_tnfa_transition_t *state;
+  regoff_t *tags;
+} tre_tnfa_reach_t;
+
+typedef struct {
+  regoff_t pos;
+  regoff_t **tags;
+} tre_reach_pos_t;
+
+
+static reg_errcode_t
+tre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *string,
+		      regoff_t *match_tags, int eflags,
+		      regoff_t *match_end_ofs)
+{
+  /* State variables required by GET_NEXT_WCHAR. */
+  tre_char_t prev_c = 0, next_c = 0;
+  const char *str_byte = string;
+  regoff_t pos = -1;
+  regoff_t pos_add_next = 1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+  int reg_notbol = eflags & REG_NOTBOL;
+  int reg_noteol = eflags & REG_NOTEOL;
+  int reg_newline = tnfa->cflags & REG_NEWLINE;
+  reg_errcode_t ret;
+
+  char *buf;
+  tre_tnfa_transition_t *trans_i;
+  tre_tnfa_reach_t *reach, *reach_next, *reach_i, *reach_next_i;
+  tre_reach_pos_t *reach_pos;
+  int *tag_i;
+  int num_tags, i;
+
+  regoff_t match_eo = -1;	   /* end offset of match (-1 if no match found yet) */
+  int new_match = 0;
+  regoff_t *tmp_tags = NULL;
+  regoff_t *tmp_iptr;
+
+#ifdef TRE_MBSTATE
+  memset(&mbstate, '\0', sizeof(mbstate));
+#endif /* TRE_MBSTATE */
+
+  if (!match_tags)
+    num_tags = 0;
+  else
+    num_tags = tnfa->num_tags;
+
+  /* Allocate memory for temporary data required for matching.	This needs to
+     be done for every matching operation to be thread safe.  This allocates
+     everything in a single large block with calloc(). */
+  {
+    size_t tbytes, rbytes, pbytes, xbytes, total_bytes;
+    char *tmp_buf;
+
+    /* Ensure that tbytes and xbytes*num_states cannot overflow, and that
+     * they don't contribute more than 1/8 of SIZE_MAX to total_bytes. */
+    if (num_tags > SIZE_MAX/(8 * sizeof(regoff_t) * tnfa->num_states))
+      return REG_ESPACE;
+
+    /* Likewise check rbytes. */
+    if (tnfa->num_states+1 > SIZE_MAX/(8 * sizeof(*reach_next)))
+      return REG_ESPACE;
+
+    /* Likewise check pbytes. */
+    if (tnfa->num_states > SIZE_MAX/(8 * sizeof(*reach_pos)))
+      return REG_ESPACE;
+
+    /* Compute the length of the block we need. */
+    tbytes = sizeof(*tmp_tags) * num_tags;
+    rbytes = sizeof(*reach_next) * (tnfa->num_states + 1);
+    pbytes = sizeof(*reach_pos) * tnfa->num_states;
+    xbytes = sizeof(regoff_t) * num_tags;
+    total_bytes =
+      (sizeof(long) - 1) * 4 /* for alignment paddings */
+      + (rbytes + xbytes * tnfa->num_states) * 2 + tbytes + pbytes;
+
+    /* Allocate the memory. */
+    buf = calloc(total_bytes, 1);
+    if (buf == NULL)
+      return REG_ESPACE;
+
+    /* Get the various pointers within tmp_buf (properly aligned). */
+    tmp_tags = (void *)buf;
+    tmp_buf = buf + tbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach_next = (void *)tmp_buf;
+    tmp_buf += rbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach = (void *)tmp_buf;
+    tmp_buf += rbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach_pos = (void *)tmp_buf;
+    tmp_buf += pbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    for (i = 0; i < tnfa->num_states; i++)
+      {
+	reach[i].tags = (void *)tmp_buf;
+	tmp_buf += xbytes;
+	reach_next[i].tags = (void *)tmp_buf;
+	tmp_buf += xbytes;
+      }
+  }
+
+  for (i = 0; i < tnfa->num_states; i++)
+    reach_pos[i].pos = -1;
+
+  GET_NEXT_WCHAR();
+  pos = 0;
+
+  reach_next_i = reach_next;
+  while (1)
+    {
+      /* If no match found yet, add the initial states to `reach_next'. */
+      if (match_eo < 0)
+	{
+	  trans_i = tnfa->initial;
+	  while (trans_i->state != NULL)
+	    {
+	      if (reach_pos[trans_i->state_id].pos < pos)
+		{
+		  if (trans_i->assertions
+		      && CHECK_ASSERTIONS(trans_i->assertions))
+		    {
+		      trans_i++;
+		      continue;
+		    }
+
+		  reach_next_i->state = trans_i->state;
+		  for (i = 0; i < num_tags; i++)
+		    reach_next_i->tags[i] = -1;
+		  tag_i = trans_i->tags;
+		  if (tag_i)
+		    while (*tag_i >= 0)
+		      {
+			if (*tag_i < num_tags)
+			  reach_next_i->tags[*tag_i] = pos;
+			tag_i++;
+		      }
+		  if (reach_next_i->state == tnfa->final)
+		    {
+		      match_eo = pos;
+		      new_match = 1;
+		      for (i = 0; i < num_tags; i++)
+			match_tags[i] = reach_next_i->tags[i];
+		    }
+		  reach_pos[trans_i->state_id].pos = pos;
+		  reach_pos[trans_i->state_id].tags = &reach_next_i->tags;
+		  reach_next_i++;
+		}
+	      trans_i++;
+	    }
+	  reach_next_i->state = NULL;
+	}
+      else
+	{
+	  if (num_tags == 0 || reach_next_i == reach_next)
+	    /* We have found a match. */
+	    break;
+	}
+
+      /* Check for end of string. */
+      if (!next_c) break;
+
+      GET_NEXT_WCHAR();
+
+      /* Swap `reach' and `reach_next'. */
+      reach_i = reach;
+      reach = reach_next;
+      reach_next = reach_i;
+
+      /* For each state in `reach', weed out states that don't fulfill the
+	 minimal matching conditions. */
+      if (tnfa->num_minimals && new_match)
+	{
+	  new_match = 0;
+	  reach_next_i = reach_next;
+	  for (reach_i = reach; reach_i->state; reach_i++)
+	    {
+	      int skip = 0;
+	      for (i = 0; tnfa->minimal_tags[i] >= 0; i += 2)
+		{
+		  int end = tnfa->minimal_tags[i];
+		  int start = tnfa->minimal_tags[i + 1];
+		  if (end >= num_tags)
+		    {
+		      skip = 1;
+		      break;
+		    }
+		  else if (reach_i->tags[start] == match_tags[start]
+			   && reach_i->tags[end] < match_tags[end])
+		    {
+		      skip = 1;
+		      break;
+		    }
+		}
+	      if (!skip)
+		{
+		  reach_next_i->state = reach_i->state;
+		  tmp_iptr = reach_next_i->tags;
+		  reach_next_i->tags = reach_i->tags;
+		  reach_i->tags = tmp_iptr;
+		  reach_next_i++;
+		}
+	    }
+	  reach_next_i->state = NULL;
+
+	  /* Swap `reach' and `reach_next'. */
+	  reach_i = reach;
+	  reach = reach_next;
+	  reach_next = reach_i;
+	}
+
+      /* For each state in `reach' see if there is a transition leaving with
+	 the current input symbol to a state not yet in `reach_next', and
+	 add the destination states to `reach_next'. */
+      reach_next_i = reach_next;
+      for (reach_i = reach; reach_i->state; reach_i++)
+	{
+	  for (trans_i = reach_i->state; trans_i->state; trans_i++)
+	    {
+	      /* Does this transition match the input symbol? */
+	      if (trans_i->code_min <= (tre_cint_t)prev_c &&
+		  trans_i->code_max >= (tre_cint_t)prev_c)
+		{
+		  if (trans_i->assertions
+		      && (CHECK_ASSERTIONS(trans_i->assertions)
+			  || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
+		    {
+		      continue;
+		    }
+
+		  /* Compute the tags after this transition. */
+		  for (i = 0; i < num_tags; i++)
+		    tmp_tags[i] = reach_i->tags[i];
+		  tag_i = trans_i->tags;
+		  if (tag_i != NULL)
+		    while (*tag_i >= 0)
+		      {
+			if (*tag_i < num_tags)
+			  tmp_tags[*tag_i] = pos;
+			tag_i++;
+		      }
+
+		  if (reach_pos[trans_i->state_id].pos < pos)
+		    {
+		      /* Found an unvisited node. */
+		      reach_next_i->state = trans_i->state;
+		      tmp_iptr = reach_next_i->tags;
+		      reach_next_i->tags = tmp_tags;
+		      tmp_tags = tmp_iptr;
+		      reach_pos[trans_i->state_id].pos = pos;
+		      reach_pos[trans_i->state_id].tags = &reach_next_i->tags;
+
+		      if (reach_next_i->state == tnfa->final
+			  && (match_eo == -1
+			      || (num_tags > 0
+				  && reach_next_i->tags[0] <= match_tags[0])))
+			{
+			  match_eo = pos;
+			  new_match = 1;
+			  for (i = 0; i < num_tags; i++)
+			    match_tags[i] = reach_next_i->tags[i];
+			}
+		      reach_next_i++;
+
+		    }
+		  else
+		    {
+		      assert(reach_pos[trans_i->state_id].pos == pos);
+		      /* Another path has also reached this state.  We choose
+			 the winner by examining the tag values for both
+			 paths. */
+		      if (tre_tag_order(num_tags, tnfa->tag_directions,
+					tmp_tags,
+					*reach_pos[trans_i->state_id].tags))
+			{
+			  /* The new path wins. */
+			  tmp_iptr = *reach_pos[trans_i->state_id].tags;
+			  *reach_pos[trans_i->state_id].tags = tmp_tags;
+			  if (trans_i->state == tnfa->final)
+			    {
+			      match_eo = pos;
+			      new_match = 1;
+			      for (i = 0; i < num_tags; i++)
+				match_tags[i] = tmp_tags[i];
+			    }
+			  tmp_tags = tmp_iptr;
+			}
+		    }
+		}
+	    }
+	}
+      reach_next_i->state = NULL;
+    }
+
+  *match_end_ofs = match_eo;
+  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
+error_exit:
+  xfree(buf);
+  return ret;
+}
+
+
+
+/***********************************************************************
+ from tre-match-backtrack.c
+***********************************************************************/
+
+/*
+  This matcher is for regexps that use back referencing.  Regexp matching
+  with back referencing is an NP-complete problem on the number of back
+  references.  The easiest way to match them is to use a backtracking
+  routine which basically goes through all possible paths in the TNFA
+  and chooses the one which results in the best (leftmost and longest)
+  match.  This can be spectacularly expensive and may run out of stack
+  space, but there really is no better known generic algorithm.	 Quoting
+  Henry Spencer from comp.compilers:
+  <URL: http://compilers.iecc.com/comparch/article/93-03-102>
+
+    POSIX.2 REs require longest match, which is really exciting to
+    implement since the obsolete ("basic") variant also includes
+    \<digit>.  I haven't found a better way of tackling this than doing
+    a preliminary match using a DFA (or simulation) on a modified RE
+    that just replicates subREs for \<digit>, and then doing a
+    backtracking match to determine whether the subRE matches were
+    right.  This can be rather slow, but I console myself with the
+    thought that people who use \<digit> deserve very slow execution.
+    (Pun unintentional but very appropriate.)
+
+*/
+
+typedef struct {
+  regoff_t pos;
+  const char *str_byte;
+  tre_tnfa_transition_t *state;
+  int state_id;
+  int next_c;
+  regoff_t *tags;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+} tre_backtrack_item_t;
+
+typedef struct tre_backtrack_struct {
+  tre_backtrack_item_t item;
+  struct tre_backtrack_struct *prev;
+  struct tre_backtrack_struct *next;
+} *tre_backtrack_t;
+
+#ifdef TRE_MBSTATE
+#define BT_STACK_MBSTATE_IN  stack->item.mbstate = (mbstate)
+#define BT_STACK_MBSTATE_OUT (mbstate) = stack->item.mbstate
+#else /* !TRE_MBSTATE */
+#define BT_STACK_MBSTATE_IN
+#define BT_STACK_MBSTATE_OUT
+#endif /* !TRE_MBSTATE */
+
+#define tre_bt_mem_new		  tre_mem_new
+#define tre_bt_mem_alloc	  tre_mem_alloc
+#define tre_bt_mem_destroy	  tre_mem_destroy
+
+
+#define BT_STACK_PUSH(_pos, _str_byte, _str_wide, _state, _state_id, _next_c, _tags, _mbstate) \
+  do									      \
+    {									      \
+      int i;								      \
+      if (!stack->next)							      \
+	{								      \
+	  tre_backtrack_t s;						      \
+	  s = tre_bt_mem_alloc(mem, sizeof(*s));			      \
+	  if (!s)							      \
+	    {								      \
+	      tre_bt_mem_destroy(mem);					      \
+	      if (tags)							      \
+		xfree(tags);						      \
+	      if (pmatch)						      \
+		xfree(pmatch);						      \
+	      if (states_seen)						      \
+		xfree(states_seen);					      \
+	      return REG_ESPACE;					      \
+	    }								      \
+	  s->prev = stack;						      \
+	  s->next = NULL;						      \
+	  s->item.tags = tre_bt_mem_alloc(mem,				      \
+					  sizeof(*tags) * tnfa->num_tags);    \
+	  if (!s->item.tags)						      \
+	    {								      \
+	      tre_bt_mem_destroy(mem);					      \
+	      if (tags)							      \
+		xfree(tags);						      \
+	      if (pmatch)						      \
+		xfree(pmatch);						      \
+	      if (states_seen)						      \
+		xfree(states_seen);					      \
+	      return REG_ESPACE;					      \
+	    }								      \
+	  stack->next = s;						      \
+	  stack = s;							      \
+	}								      \
+      else								      \
+	stack = stack->next;						      \
+      stack->item.pos = (_pos);						      \
+      stack->item.str_byte = (_str_byte);				      \
+      stack->item.state = (_state);					      \
+      stack->item.state_id = (_state_id);				      \
+      stack->item.next_c = (_next_c);					      \
+      for (i = 0; i < tnfa->num_tags; i++)				      \
+	stack->item.tags[i] = (_tags)[i];				      \
+      BT_STACK_MBSTATE_IN;						      \
+    }									      \
+  while (0)
+
+#define BT_STACK_POP()							      \
+  do									      \
+    {									      \
+      int i;								      \
+      assert(stack->prev);						      \
+      pos = stack->item.pos;						      \
+      str_byte = stack->item.str_byte;					      \
+      state = stack->item.state;					      \
+      next_c = stack->item.next_c;					      \
+      for (i = 0; i < tnfa->num_tags; i++)				      \
+	tags[i] = stack->item.tags[i];					      \
+      BT_STACK_MBSTATE_OUT;						      \
+      stack = stack->prev;						      \
+    }									      \
+  while (0)
+
+#undef MIN
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+
+static reg_errcode_t
+tre_tnfa_run_backtrack(const tre_tnfa_t *tnfa, const void *string,
+		       regoff_t *match_tags, int eflags, regoff_t *match_end_ofs)
+{
+  /* State variables required by GET_NEXT_WCHAR. */
+  tre_char_t prev_c = 0, next_c = 0;
+  const char *str_byte = string;
+  regoff_t pos = 0;
+  regoff_t pos_add_next = 1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+  int reg_notbol = eflags & REG_NOTBOL;
+  int reg_noteol = eflags & REG_NOTEOL;
+  int reg_newline = tnfa->cflags & REG_NEWLINE;
+
+  /* These are used to remember the necessary values of the above
+     variables to return to the position where the current search
+     started from. */
+  int next_c_start;
+  const char *str_byte_start;
+  regoff_t pos_start = -1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate_start;
+#endif /* TRE_MBSTATE */
+
+  /* End offset of best match so far, or -1 if no match found yet. */
+  regoff_t match_eo = -1;
+  /* Tag arrays. */
+  int *next_tags;
+  regoff_t *tags = NULL;
+  /* Current TNFA state. */
+  tre_tnfa_transition_t *state;
+  int *states_seen = NULL;
+
+  /* Memory allocator to for allocating the backtracking stack. */
+  tre_mem_t mem = tre_bt_mem_new();
+
+  /* The backtracking stack. */
+  tre_backtrack_t stack;
+
+  tre_tnfa_transition_t *trans_i;
+  regmatch_t *pmatch = NULL;
+  int ret;
+
+#ifdef TRE_MBSTATE
+  memset(&mbstate, '\0', sizeof(mbstate));
+#endif /* TRE_MBSTATE */
+
+  if (!mem)
+    return REG_ESPACE;
+  stack = tre_bt_mem_alloc(mem, sizeof(*stack));
+  if (!stack)
+    {
+      ret = REG_ESPACE;
+      goto error_exit;
+    }
+  stack->prev = NULL;
+  stack->next = NULL;
+
+  if (tnfa->num_tags)
+    {
+      tags = xmalloc(sizeof(*tags) * tnfa->num_tags);
+      if (!tags)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+  if (tnfa->num_submatches)
+    {
+      pmatch = xmalloc(sizeof(*pmatch) * tnfa->num_submatches);
+      if (!pmatch)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+  if (tnfa->num_states)
+    {
+      states_seen = xmalloc(sizeof(*states_seen) * tnfa->num_states);
+      if (!states_seen)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+
+ retry:
+  {
+    int i;
+    for (i = 0; i < tnfa->num_tags; i++)
+      {
+	tags[i] = -1;
+	if (match_tags)
+	  match_tags[i] = -1;
+      }
+    for (i = 0; i < tnfa->num_states; i++)
+      states_seen[i] = 0;
+  }
+
+  state = NULL;
+  pos = pos_start;
+  GET_NEXT_WCHAR();
+  pos_start = pos;
+  next_c_start = next_c;
+  str_byte_start = str_byte;
+#ifdef TRE_MBSTATE
+  mbstate_start = mbstate;
+#endif /* TRE_MBSTATE */
+
+  /* Handle initial states. */
+  next_tags = NULL;
+  for (trans_i = tnfa->initial; trans_i->state; trans_i++)
+    {
+      if (trans_i->assertions && CHECK_ASSERTIONS(trans_i->assertions))
+	{
+	  continue;
+	}
+      if (state == NULL)
+	{
+	  /* Start from this state. */
+	  state = trans_i->state;
+	  next_tags = trans_i->tags;
+	}
+      else
+	{
+	  /* Backtrack to this state. */
+	  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
+			trans_i->state_id, next_c, tags, mbstate);
+	  {
+	    int *tmp = trans_i->tags;
+	    if (tmp)
+	      while (*tmp >= 0)
+		stack->item.tags[*tmp++] = pos;
+	  }
+	}
+    }
+
+  if (next_tags)
+    for (; *next_tags >= 0; next_tags++)
+      tags[*next_tags] = pos;
+
+
+  if (state == NULL)
+    goto backtrack;
+
+  while (1)
+    {
+      tre_tnfa_transition_t *next_state;
+      int empty_br_match;
+
+      if (state == tnfa->final)
+	{
+	  if (match_eo < pos
+	      || (match_eo == pos
+		  && match_tags
+		  && tre_tag_order(tnfa->num_tags, tnfa->tag_directions,
+				   tags, match_tags)))
+	    {
+	      int i;
+	      /* This match wins the previous match. */
+	      match_eo = pos;
+	      if (match_tags)
+		for (i = 0; i < tnfa->num_tags; i++)
+		  match_tags[i] = tags[i];
+	    }
+	  /* Our TNFAs never have transitions leaving from the final state,
+	     so we jump right to backtracking. */
+	  goto backtrack;
+	}
+
+      /* Go to the next character in the input string. */
+      empty_br_match = 0;
+      trans_i = state;
+      if (trans_i->state && trans_i->assertions & ASSERT_BACKREF)
+	{
+	  /* This is a back reference state.  All transitions leaving from
+	     this state have the same back reference "assertion".  Instead
+	     of reading the next character, we match the back reference. */
+	  regoff_t so, eo;
+	  int bt = trans_i->u.backref;
+	  regoff_t bt_len;
+	  int result;
+
+	  /* Get the substring we need to match against.  Remember to
+	     turn off REG_NOSUB temporarily. */
+	  tre_fill_pmatch(bt + 1, pmatch, tnfa->cflags & ~REG_NOSUB,
+			  tnfa, tags, pos);
+	  so = pmatch[bt].rm_so;
+	  eo = pmatch[bt].rm_eo;
+	  bt_len = eo - so;
+
+	  result = strncmp((const char*)string + so, str_byte - 1,
+				 (size_t)bt_len);
+
+	  if (result == 0)
+	    {
+	      /* Back reference matched.  Check for infinite loop. */
+	      if (bt_len == 0)
+		empty_br_match = 1;
+	      if (empty_br_match && states_seen[trans_i->state_id])
+		{
+		  goto backtrack;
+		}
+
+	      states_seen[trans_i->state_id] = empty_br_match;
+
+	      /* Advance in input string and resync `prev_c', `next_c'
+		 and pos. */
+	      str_byte += bt_len - 1;
+	      pos += bt_len - 1;
+	      GET_NEXT_WCHAR();
+	    }
+	  else
+	    {
+	      goto backtrack;
+	    }
+	}
+      else
+	{
+	  /* Check for end of string. */
+	  if (next_c == L'\0')
+		goto backtrack;
+
+	  /* Read the next character. */
+	  GET_NEXT_WCHAR();
+	}
+
+      next_state = NULL;
+      for (trans_i = state; trans_i->state; trans_i++)
+	{
+	  if (trans_i->code_min <= (tre_cint_t)prev_c
+	      && trans_i->code_max >= (tre_cint_t)prev_c)
+	    {
+	      if (trans_i->assertions
+		  && (CHECK_ASSERTIONS(trans_i->assertions)
+		      || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
+		{
+		  continue;
+		}
+
+	      if (next_state == NULL)
+		{
+		  /* First matching transition. */
+		  next_state = trans_i->state;
+		  next_tags = trans_i->tags;
+		}
+	      else
+		{
+		  /* Second matching transition.  We may need to backtrack here
+		     to take this transition instead of the first one, so we
+		     push this transition in the backtracking stack so we can
+		     jump back here if needed. */
+		  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
+				trans_i->state_id, next_c, tags, mbstate);
+		  {
+		    int *tmp;
+		    for (tmp = trans_i->tags; tmp && *tmp >= 0; tmp++)
+		      stack->item.tags[*tmp] = pos;
+		  }
+#if 0 /* XXX - it's important not to look at all transitions here to keep
+	 the stack small! */
+		  break;
+#endif
+		}
+	    }
+	}
+
+      if (next_state != NULL)
+	{
+	  /* Matching transitions were found.  Take the first one. */
+	  state = next_state;
+
+	  /* Update the tag values. */
+	  if (next_tags)
+	    while (*next_tags >= 0)
+	      tags[*next_tags++] = pos;
+	}
+      else
+	{
+	backtrack:
+	  /* A matching transition was not found.  Try to backtrack. */
+	  if (stack->prev)
+	    {
+	      if (stack->item.state->assertions & ASSERT_BACKREF)
+		{
+		  states_seen[stack->item.state_id] = 0;
+		}
+
+	      BT_STACK_POP();
+	    }
+	  else if (match_eo < 0)
+	    {
+	      /* Try starting from a later position in the input string. */
+	      /* Check for end of string. */
+	      if (next_c == L'\0')
+		    {
+		      break;
+		    }
+	      next_c = next_c_start;
+#ifdef TRE_MBSTATE
+	      mbstate = mbstate_start;
+#endif /* TRE_MBSTATE */
+	      str_byte = str_byte_start;
+	      goto retry;
+	    }
+	  else
+	    {
+	      break;
+	    }
+	}
+    }
+
+  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
+  *match_end_ofs = match_eo;
+
+ error_exit:
+  tre_bt_mem_destroy(mem);
+#ifndef TRE_USE_ALLOCA
+  if (tags)
+    xfree(tags);
+  if (pmatch)
+    xfree(pmatch);
+  if (states_seen)
+    xfree(states_seen);
+#endif /* !TRE_USE_ALLOCA */
+
+  return ret;
+}
+
+/***********************************************************************
+ from regexec.c
+***********************************************************************/
+
+/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
+   endpoint values. */
+static void
+tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
+		const tre_tnfa_t *tnfa, regoff_t *tags, regoff_t match_eo)
+{
+  tre_submatch_data_t *submatch_data;
+  unsigned int i, j;
+  int *parents;
+
+  i = 0;
+  if (match_eo >= 0 && !(cflags & REG_NOSUB))
+    {
+      /* Construct submatch offsets from the tags. */
+      submatch_data = tnfa->submatch_data;
+      while (i < tnfa->num_submatches && i < nmatch)
+	{
+	  if (submatch_data[i].so_tag == tnfa->end_tag)
+	    pmatch[i].rm_so = match_eo;
+	  else
+	    pmatch[i].rm_so = tags[submatch_data[i].so_tag];
+
+	  if (submatch_data[i].eo_tag == tnfa->end_tag)
+	    pmatch[i].rm_eo = match_eo;
+	  else
+	    pmatch[i].rm_eo = tags[submatch_data[i].eo_tag];
+
+	  /* If either of the endpoints were not used, this submatch
+	     was not part of the match. */
+	  if (pmatch[i].rm_so == -1 || pmatch[i].rm_eo == -1)
+	    pmatch[i].rm_so = pmatch[i].rm_eo = -1;
+
+	  i++;
+	}
+      /* Reset all submatches that are not within all of their parent
+	 submatches. */
+      i = 0;
+      while (i < tnfa->num_submatches && i < nmatch)
+	{
+	  if (pmatch[i].rm_eo == -1)
+	    assert(pmatch[i].rm_so == -1);
+	  assert(pmatch[i].rm_so <= pmatch[i].rm_eo);
+
+	  parents = submatch_data[i].parents;
+	  if (parents != NULL)
+	    for (j = 0; parents[j] >= 0; j++)
+	      {
+		if (pmatch[i].rm_so < pmatch[parents[j]].rm_so
+		    || pmatch[i].rm_eo > pmatch[parents[j]].rm_eo)
+		  pmatch[i].rm_so = pmatch[i].rm_eo = -1;
+	      }
+	  i++;
+	}
+    }
+
+  while (i < nmatch)
+    {
+      pmatch[i].rm_so = -1;
+      pmatch[i].rm_eo = -1;
+      i++;
+    }
+}
+
+
+/*
+  Wrapper functions for POSIX compatible regexp matching.
+*/
+
+int
+regexec(const regex_t *restrict preg, const char *restrict string,
+	  size_t nmatch, regmatch_t pmatch[restrict], int eflags)
+{
+  tre_tnfa_t *tnfa = (void *)preg->TRE_REGEX_T_FIELD;
+  reg_errcode_t status;
+  regoff_t *tags = NULL, eo;
+  if (tnfa->cflags & REG_NOSUB) nmatch = 0;
+  if (tnfa->num_tags > 0 && nmatch > 0)
+    {
+      tags = xmalloc(sizeof(*tags) * tnfa->num_tags);
+      if (tags == NULL)
+	return REG_ESPACE;
+    }
+
+  /* Dispatch to the appropriate matcher. */
+  if (tnfa->have_backrefs)
+    {
+      /* The regex has back references, use the backtracking matcher. */
+      status = tre_tnfa_run_backtrack(tnfa, string, tags, eflags, &eo);
+    }
+  else
+    {
+      /* Exact matching, no back references, use the parallel matcher. */
+      status = tre_tnfa_run_parallel(tnfa, string, tags, eflags, &eo);
+    }
+
+  if (status == REG_OK)
+    /* A match was found, so fill the submatch registers. */
+    tre_fill_pmatch(nmatch, pmatch, tnfa->cflags, tnfa, tags, eo);
+  if (tags)
+    xfree(tags);
+  return status;
+}
diff --git a/options/posix/generic/regex/tre-mem.c b/options/posix/generic/regex/tre-mem.c
new file mode 100644
index 0000000..86f809d
--- /dev/null
+++ b/options/posix/generic/regex/tre-mem.c
@@ -0,0 +1,158 @@
+/*
+  tre-mem.c - TRE memory allocator
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+/*
+  This memory allocator is for allocating small memory blocks efficiently
+  in terms of memory overhead and execution speed.  The allocated blocks
+  cannot be freed individually, only all at once.  There can be multiple
+  allocators, though.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "tre.h"
+
+/*
+  This memory allocator is for allocating small memory blocks efficiently
+  in terms of memory overhead and execution speed.  The allocated blocks
+  cannot be freed individually, only all at once.  There can be multiple
+  allocators, though.
+*/
+
+/* Returns a new memory allocator or NULL if out of memory. */
+tre_mem_t
+tre_mem_new_impl(int provided, void *provided_block)
+{
+  tre_mem_t mem;
+  if (provided)
+    {
+      mem = provided_block;
+      memset(mem, 0, sizeof(*mem));
+    }
+  else
+    mem = xcalloc(1, sizeof(*mem));
+  if (mem == NULL)
+    return NULL;
+  return mem;
+}
+
+
+/* Frees the memory allocator and all memory allocated with it. */
+void
+tre_mem_destroy(tre_mem_t mem)
+{
+  tre_list_t *tmp, *l = mem->blocks;
+
+  while (l != NULL)
+    {
+      xfree(l->data);
+      tmp = l->next;
+      xfree(l);
+      l = tmp;
+    }
+  xfree(mem);
+}
+
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed. */
+void *
+tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
+		   int zero, size_t size)
+{
+  void *ptr;
+
+  if (mem->failed)
+    {
+      return NULL;
+    }
+
+  if (mem->n < size)
+    {
+      /* We need more memory than is available in the current block.
+	 Allocate a new block. */
+      tre_list_t *l;
+      if (provided)
+	{
+	  if (provided_block == NULL)
+	    {
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  mem->ptr = provided_block;
+	  mem->n = TRE_MEM_BLOCK_SIZE;
+	}
+      else
+	{
+	  int block_size;
+	  if (size * 8 > TRE_MEM_BLOCK_SIZE)
+	    block_size = size * 8;
+	  else
+	    block_size = TRE_MEM_BLOCK_SIZE;
+	  l = xmalloc(sizeof(*l));
+	  if (l == NULL)
+	    {
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  l->data = xmalloc(block_size);
+	  if (l->data == NULL)
+	    {
+	      xfree(l);
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  l->next = NULL;
+	  if (mem->current != NULL)
+	    mem->current->next = l;
+	  if (mem->blocks == NULL)
+	    mem->blocks = l;
+	  mem->current = l;
+	  mem->ptr = l->data;
+	  mem->n = block_size;
+	}
+    }
+
+  /* Make sure the next pointer will be aligned. */
+  size += ALIGN(mem->ptr + size, long);
+
+  /* Allocate from current block. */
+  ptr = mem->ptr;
+  mem->ptr += size;
+  mem->n -= size;
+
+  /* Set to zero if needed. */
+  if (zero)
+    memset(ptr, 0, size);
+
+  return ptr;
+}
diff --git a/options/posix/generic/regex/tre.h b/options/posix/generic/regex/tre.h
new file mode 100644
index 0000000..5b4e802
--- /dev/null
+++ b/options/posix/generic/regex/tre.h
@@ -0,0 +1,233 @@
+/*
+  tre-internal.h - TRE internal definitions
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <regex.h>
+#include <wchar.h>
+#include <wctype.h>
+
+#undef  TRE_MBSTATE
+
+#define NDEBUG
+
+#define TRE_REGEX_T_FIELD __opaque
+typedef int reg_errcode_t;
+
+typedef wchar_t tre_char_t;
+
+#define DPRINT(msg) do { } while(0)
+
+#define elementsof(x)	( sizeof(x) / sizeof(x[0]) )
+
+#define tre_mbrtowc(pwc, s, n, ps) ({ *pwc = s; 1; })
+
+/* Wide characters. */
+typedef wint_t tre_cint_t;
+#define TRE_CHAR_MAX 0x10ffff
+
+#define tre_isalnum iswalnum
+#define tre_isalpha iswalpha
+#define tre_isblank iswblank
+#define tre_iscntrl iswcntrl
+#define tre_isdigit iswdigit
+#define tre_isgraph iswgraph
+#define tre_islower iswlower
+#define tre_isprint iswprint
+#define tre_ispunct iswpunct
+#define tre_isspace iswspace
+#define tre_isupper iswupper
+#define tre_isxdigit iswxdigit
+
+#define tre_tolower towlower
+#define tre_toupper towupper
+#define tre_strlen  wcslen
+
+/* Use system provided iswctype() and wctype(). */
+typedef wctype_t tre_ctype_t;
+#define tre_isctype iswctype
+#define tre_ctype   wctype
+
+/* Returns number of bytes to add to (char *)ptr to make it
+   properly aligned for the type. */
+#define ALIGN(ptr, type) \
+  ((((long)ptr) % sizeof(type)) \
+   ? (sizeof(type) - (((long)ptr) % sizeof(type))) \
+   : 0)
+
+#undef MAX
+#undef MIN
+#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
+#define MIN(a, b) (((a) <= (b)) ? (a) : (b))
+
+/* TNFA transition type. A TNFA state is an array of transitions,
+   the terminator is a transition with NULL `state'. */
+typedef struct tnfa_transition tre_tnfa_transition_t;
+
+struct tnfa_transition {
+  /* Range of accepted characters. */
+  tre_cint_t code_min;
+  tre_cint_t code_max;
+  /* Pointer to the destination state. */
+  tre_tnfa_transition_t *state;
+  /* ID number of the destination state. */
+  int state_id;
+  /* -1 terminated array of tags (or NULL). */
+  int *tags;
+  /* Assertion bitmap. */
+  int assertions;
+  /* Assertion parameters. */
+  union {
+    /* Character class assertion. */
+    tre_ctype_t class;
+    /* Back reference assertion. */
+    int backref;
+  } u;
+  /* Negative character class assertions. */
+  tre_ctype_t *neg_classes;
+};
+
+
+/* Assertions. */
+#define ASSERT_AT_BOL		  1   /* Beginning of line. */
+#define ASSERT_AT_EOL		  2   /* End of line. */
+#define ASSERT_CHAR_CLASS	  4   /* Character class in `class'. */
+#define ASSERT_CHAR_CLASS_NEG	  8   /* Character classes in `neg_classes'. */
+#define ASSERT_AT_BOW		 16   /* Beginning of word. */
+#define ASSERT_AT_EOW		 32   /* End of word. */
+#define ASSERT_AT_WB		 64   /* Word boundary. */
+#define ASSERT_AT_WB_NEG	128   /* Not a word boundary. */
+#define ASSERT_BACKREF		256   /* A back reference in `backref'. */
+#define ASSERT_LAST		256
+
+/* Tag directions. */
+typedef enum {
+  TRE_TAG_MINIMIZE = 0,
+  TRE_TAG_MAXIMIZE = 1
+} tre_tag_direction_t;
+
+/* Instructions to compute submatch register values from tag values
+   after a successful match.  */
+struct tre_submatch_data {
+  /* Tag that gives the value for rm_so (submatch start offset). */
+  int so_tag;
+  /* Tag that gives the value for rm_eo (submatch end offset). */
+  int eo_tag;
+  /* List of submatches this submatch is contained in. */
+  int *parents;
+};
+
+typedef struct tre_submatch_data tre_submatch_data_t;
+
+
+/* TNFA definition. */
+typedef struct tnfa tre_tnfa_t;
+
+struct tnfa {
+  tre_tnfa_transition_t *transitions;
+  unsigned int num_transitions;
+  tre_tnfa_transition_t *initial;
+  tre_tnfa_transition_t *final;
+  tre_submatch_data_t *submatch_data;
+  char *firstpos_chars;
+  int first_char;
+  unsigned int num_submatches;
+  tre_tag_direction_t *tag_directions;
+  int *minimal_tags;
+  int num_tags;
+  int num_minimals;
+  int end_tag;
+  int num_states;
+  int cflags;
+  int have_backrefs;
+  int have_approx;
+};
+
+/* from tre-mem.h: */
+
+#define TRE_MEM_BLOCK_SIZE 1024
+
+typedef struct tre_list {
+  void *data;
+  struct tre_list *next;
+} tre_list_t;
+
+typedef struct tre_mem_struct {
+  tre_list_t *blocks;
+  tre_list_t *current;
+  char *ptr;
+  size_t n;
+  int failed;
+  void **provided;
+} *tre_mem_t;
+
+#define tre_mem_new_impl   __tre_mem_new_impl
+#define tre_mem_alloc_impl __tre_mem_alloc_impl
+#define tre_mem_destroy    __tre_mem_destroy
+
+#define hidden __attribute__((__visibility__("hidden")))
+
+hidden tre_mem_t tre_mem_new_impl(int provided, void *provided_block);
+hidden void *tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
+                                int zero, size_t size);
+
+/* Returns a new memory allocator or NULL if out of memory. */
+#define tre_mem_new()  tre_mem_new_impl(0, NULL)
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed. */
+#define tre_mem_alloc(mem, size) tre_mem_alloc_impl(mem, 0, NULL, 0, size)
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed.  The memory
+   is set to zero. */
+#define tre_mem_calloc(mem, size) tre_mem_alloc_impl(mem, 0, NULL, 1, size)
+
+#ifdef TRE_USE_ALLOCA
+/* alloca() versions.  Like above, but memory is allocated with alloca()
+   instead of malloc(). */
+
+#define tre_mem_newa() \
+  tre_mem_new_impl(1, alloca(sizeof(struct tre_mem_struct)))
+
+#define tre_mem_alloca(mem, size)					      \
+  ((mem)->n >= (size)							      \
+   ? tre_mem_alloc_impl((mem), 1, NULL, 0, (size))			      \
+   : tre_mem_alloc_impl((mem), 1, alloca(TRE_MEM_BLOCK_SIZE), 0, (size)))
+#endif /* TRE_USE_ALLOCA */
+
+
+/* Frees the memory allocator and all memory allocated with it. */
+hidden void tre_mem_destroy(tre_mem_t mem);
+
+#define xmalloc malloc
+#define xcalloc calloc
+#define xfree free
+#define xrealloc realloc
+
diff --git a/options/posix/generic/unistd-stubs.cpp b/options/posix/generic/unistd-stubs.cpp
index 4917a15..c134e42 100644
--- a/options/posix/generic/unistd-stubs.cpp
+++ b/options/posix/generic/unistd-stubs.cpp
@@ -848,12 +848,12 @@ int ttyname_r(int, char *, size_t) {
 }
 
 int unlink(const char *path) {
-	if(!mlibc::sys_unlink) {
+	if(!mlibc::sys_unlinkat) {
 		MLIBC_MISSING_SYSDEP();
 		errno = ENOSYS;
 		return -1;
 	}
-	if(int e = mlibc::sys_unlink(path); e) {
+	if(int e = mlibc::sys_unlinkat(AT_FDCWD, path, 0); e) {
 		errno = e;
 		return -1;
 	}
diff --git a/options/posix/include/mlibc/posix-sysdeps.hpp b/options/posix/include/mlibc/posix-sysdeps.hpp
index 0025f8f..a94f26b 100644
--- a/options/posix/include/mlibc/posix-sysdeps.hpp
+++ b/options/posix/include/mlibc/posix-sysdeps.hpp
@@ -91,7 +91,8 @@ int sys_close(int fd);
 [[gnu::weak]] void sys_yield();
 [[gnu::weak]] int sys_sleep(time_t *secs, long *nanos);
 [[gnu::weak]] int sys_fork(pid_t *child);
-[[gnu::weak]] int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *pid_out);
+[[gnu::weak]] int sys_clone(void *tcb, pid_t *pid_out, void *stack);
+[[gnu::weak]] int sys_prepare_stack(void **stack, void *entry, void *user_arg, void* tcb, size_t *stack_size, size_t *guard_size);
 [[gnu::weak]] int sys_execve(const char *path, char *const argv[], char *const envp[]);
 [[gnu::weak]] int sys_pselect(int num_fds, fd_set *read_set, fd_set *write_set,
 		fd_set *except_set, const struct timespec *timeout, const sigset_t *sigmask, int *num_events);
diff --git a/options/posix/include/pthread.h b/options/posix/include/pthread.h
index 2f2e2f7..c05808e 100644
--- a/options/posix/include/pthread.h
+++ b/options/posix/include/pthread.h
@@ -25,6 +25,10 @@ extern "C" {
 #define PTHREAD_SCOPE_SYSTEM 0
 #define PTHREAD_SCOPE_PROCESS 1
 
+// Values for pthread_attr_{get,set}inheritsched
+#define PTHREAD_INHERIT_SCHED 0
+#define PTHREAD_EXPLICIT_SCHED 1
+
 // values for pthread_{get,set}canceltype().
 #define PTHREAD_CANCEL_DEFERRED 0
 #define PTHREAD_CANCEL_ASYNCHRONOUS 1
@@ -61,11 +65,18 @@ extern "C" {
 #define PTHREAD_INHERIT_SCHED 0
 #define PTHREAD_EXPLICIT_SCHED 1
 
+#define PTHREAD_STACK_MIN 16384
+
 // TODO: move to own file and include in sys/types.h
 struct __mlibc_threadattr {
-	// TODO: the guardsize attribute needs to be supported here.
-
-	int __mlibc_deatchstate;
+	size_t __mlibc_guardsize;
+	size_t __mlibc_stacksize;
+	void *__mlibc_stackaddr;
+	int __mlibc_detachstate;
+	int __mlibc_scope;
+	int __mlibc_inheritsched;
+	struct sched_param __mlibc_schedparam;
+	int __mlibc_schedpolicy;
 };
 typedef struct __mlibc_threadattr pthread_attr_t;
 
@@ -126,6 +137,9 @@ typedef struct __mlibc_rwlockattr pthread_rwlockattr_t;
 // pthread_attr and pthread functions.
 // ----------------------------------------------------------------------------
 
+int pthread_rwlockattr_init(pthread_rwlockattr_t *);
+int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
+
 // pthread_attr functions.
 int pthread_attr_init(pthread_attr_t *);
 int pthread_attr_destroy(pthread_attr_t *);
@@ -136,20 +150,33 @@ int pthread_attr_setdetachstate(pthread_attr_t *, int);
 int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict);
 int pthread_attr_setstacksize(pthread_attr_t *, size_t);
 
+int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
+int pthread_attr_setstackaddr(pthread_attr_t *, void *);
+
+int pthread_attr_getstack(const pthread_attr_t *, void **, size_t*);
+int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
+
 int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict);
 int pthread_attr_setguardsize(pthread_attr_t *, size_t);
 
-int pthread_attr_getscope(const pthread_attr_t *, int);
+int pthread_attr_getscope(const pthread_attr_t *, int*);
 int pthread_attr_setscope(pthread_attr_t *, int);
 
+int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict);
+int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict);
+
 int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict);
-int pthread_attr_setschedpolicy(pthread_attr_t *, int);
+int pthread_attr_setschedpolicy(pthread_attr_t *__restrict, int);
+
+int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict);
+int pthread_attr_setinheritsched(pthread_attr_t *__restrict, int);
 
 int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict);
 int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict);
 
-int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict);
-int pthread_attr_setinheritsched(pthread_attr_t *, int);
+int pthread_getattr_np(pthread_t, pthread_attr_t *);
+
+int pthread_getattr_np(pthread_t, pthread_attr_t *);
 
 // pthread functions.
 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict,
diff --git a/options/posix/include/regex.h b/options/posix/include/regex.h
index 1579c95..c1034c6 100644
--- a/options/posix/include/regex.h
+++ b/options/posix/include/regex.h
@@ -11,7 +11,9 @@ typedef ptrdiff_t regoff_t;
 
 typedef struct re_pattern_buffer {
 	size_t re_nsub;
-	void *__impl;
+	void *__opaque, *__padding[4];
+	size_t __nsub2;
+	char __padding2;
 } regex_t;
 
 typedef struct {
diff --git a/options/posix/meson.build b/options/posix/meson.build
index 285e07c..e3941e2 100644
--- a/options/posix/meson.build
+++ b/options/posix/meson.build
@@ -24,7 +24,14 @@ libc_sources += files(
 	'generic/posix_time.cpp',
 	'generic/pthread-stubs.cpp',
 	'generic/pwd-stubs.cpp',
-	'generic/regex.cpp',
+
+	'generic/regex/fnmatch.c',
+	'generic/regex/glob.c',
+	'generic/regex/regcomp.c',
+	'generic/regex/regerror.c',
+	'generic/regex/regexec.c',
+	'generic/regex/tre-mem.c',
+
 	'generic/resolv_conf.cpp',
 	'generic/sched-stubs.cpp',
 	'generic/spawn-stubs.cpp',
@@ -53,8 +60,6 @@ libc_sources += files(
 	'generic/search.cpp',
 	'generic/sys-msg.cpp',
 	'generic/sys-sem.cpp',
-	'musl-generic/fnmatch.cpp',
-	'musl-generic/glob.cpp',
 )
 
 if not no_headers
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index 9620645..dbc619d 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -13,8 +13,8 @@
 uintptr_t libraryBase = 0x41000000;
 
 bool verbose = false;
-bool stillSlightlyVerbose = false;
-bool logBaseAddresses = false;
+bool stillSlightlyVerbose = true;
+bool logBaseAddresses = true;
 bool eagerBinding = true;
 
 #if defined(__x86_64__)
diff --git a/sysdeps/dripos/generic/generic.cpp b/sysdeps/dripos/generic/generic.cpp
index 0a85169..ba1f536 100644
--- a/sysdeps/dripos/generic/generic.cpp
+++ b/sysdeps/dripos/generic/generic.cpp
@@ -214,13 +214,12 @@ int sys_futex_wake(int *pointer) {
 // All remaining functions are disabled in ldso.
 #ifndef MLIBC_BUILDING_RTDL
 
-int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *tid_out) {
-	void *sp = prepare_stack(entry, user_arg, tcb);
+int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
     int tid;
 
     asm volatile ("syscall"
         : "=a"(tid)
-        : "a"(67), "D"(__mlibc_start_thread), "S"(sp), "d"(tcb)
+        : "a"(67), "D"(__mlibc_start_thread), "S"(stack), "d"(tcb)
         : "rcx", "r11");
 
 	if (tid_out)
diff --git a/sysdeps/dripos/generic/thread.cpp b/sysdeps/dripos/generic/thread.cpp
index 35e7a9b..1e0cedf 100644
--- a/sysdeps/dripos/generic/thread.cpp
+++ b/sysdeps/dripos/generic/thread.cpp
@@ -28,17 +28,29 @@ extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
 
 namespace mlibc {
 
-void *prepare_stack(void *entry, void *user_arg, void *tcb) {
-	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
-			mmap(nullptr, 0x200000,
-				PROT_READ | PROT_WRITE,
-				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-			) + 0x200000);
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	uintptr_t *sp;
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+	*guard_size = 0;
+
+	if (*stack) {
+		sp = reinterpret_cast<uintptr_t *>(*stack);
+	} else {
+		sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
+					mmap(nullptr, *stack_size,
+						PROT_READ | PROT_WRITE,
+						MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+					) + *stack_size);
+	}
 
 	*--sp = reinterpret_cast<uintptr_t>(tcb);
 	*--sp = reinterpret_cast<uintptr_t>(user_arg);
 	*--sp = reinterpret_cast<uintptr_t>(entry);
-	return sp;
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
 }
 
 } //namespace mlibc
diff --git a/sysdeps/lemon/generic/lemon.cpp b/sysdeps/lemon/generic/lemon.cpp
index fd94b7d..795f9b6 100644
--- a/sysdeps/lemon/generic/lemon.cpp
+++ b/sysdeps/lemon/generic/lemon.cpp
@@ -140,8 +140,7 @@ void sys_yield(){
 	syscall(SYS_YIELD);
 }
 
-int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *tid_out){
-	auto stack = prepare_stack(entry, user_arg, tcb);
+int sys_clone(void *tcb, pid_t *tid_out, void *stack){
 	pid_t tid = syscall(SYS_SPAWN_THREAD, __mlibc_start_thread, stack);
 
 	if(tid < 0){
@@ -192,4 +191,4 @@ int sys_getentropy(void *buffer, size_t length){
 }
 #endif
 
-} 
+}
diff --git a/sysdeps/lemon/generic/thread.cpp b/sysdeps/lemon/generic/thread.cpp
index 574b98d..d0d00ba 100644
--- a/sysdeps/lemon/generic/thread.cpp
+++ b/sysdeps/lemon/generic/thread.cpp
@@ -28,17 +28,29 @@ extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
 
 namespace mlibc {
 
-void* prepare_stack(void *entry, void *user_arg, void *tcb) {
-	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
-			mmap(nullptr, 0x1000000, 
-				PROT_READ | PROT_WRITE, 
-				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-			) + 0x1000000);
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+	*guard_size = 0;
+
+	uintptr_t *sp;
+	if (*stack) {
+		sp = reinterpret_cast<uintptr_t *>(*stack);
+	} else {
+		sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
+					mmap(nullptr, *stack_size,
+						PROT_READ | PROT_WRITE,
+						MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+					) + *stack_size);
+	}
 
 	*--sp = reinterpret_cast<uintptr_t>(tcb);
 	*--sp = reinterpret_cast<uintptr_t>(user_arg);
 	*--sp = reinterpret_cast<uintptr_t>(entry);
-	return sp;
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
 }
 
 } //namespace mlibc
diff --git a/sysdeps/linux/generic/sysdeps.cpp b/sysdeps/linux/generic/sysdeps.cpp
index 582115a..5e98472 100644
--- a/sysdeps/linux/generic/sysdeps.cpp
+++ b/sysdeps/linux/generic/sysdeps.cpp
@@ -366,9 +366,7 @@ int sys_sigprocmask(int how, const sigset_t *set, sigset_t *old) {
 	return 0;
 }
 
-int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *pid_out) {
-        void *stack = prepare_stack(entry, user_arg);
-
+int sys_clone(void *tcb, pid_t *pid_out, void *stack) {
 	unsigned long flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
 		| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_SETTLS
 		| CLONE_PARENT_SETTID;
diff --git a/sysdeps/linux/x86_64/thread.cpp b/sysdeps/linux/x86_64/thread.cpp
index 94d03b6..ed2ec5a 100644
--- a/sysdeps/linux/x86_64/thread.cpp
+++ b/sysdeps/linux/x86_64/thread.cpp
@@ -5,11 +5,7 @@
 #include <sys/mman.h>
 #include <stdint.h>
 #include <stddef.h>
-
-namespace {
-	constexpr unsigned int STACK_SIZE = 0x200000;
-	constexpr unsigned int GUARD_SIZE = 0x2000;
-}
+#include <errno.h>
 
 extern "C" void __mlibc_enter_thread(void *entry, void *user_arg) {
 	// The linux kernel already sets the TCB in sys_clone().
@@ -31,20 +27,34 @@ extern "C" void __mlibc_enter_thread(void *entry, void *user_arg) {
 
 namespace mlibc {
 
-void *prepare_stack(void *entry, void *user_arg) {
-	uintptr_t map = reinterpret_cast<uintptr_t>(
-			mmap(nullptr, STACK_SIZE + GUARD_SIZE,
-				PROT_NONE,
-				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-			);
-	__ensure(reinterpret_cast<void*>(map) != MAP_FAILED);
-	int ret = mprotect(reinterpret_cast<void*>(map + GUARD_SIZE), STACK_SIZE,
-			PROT_READ | PROT_WRITE);
-	__ensure(!ret);
-
-	auto sp = reinterpret_cast<uintptr_t*>(map + STACK_SIZE + GUARD_SIZE);
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	(void)tcb;
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+
+	uintptr_t map;
+	if (*stack) {
+		map = reinterpret_cast<uintptr_t>(*stack);
+	} else {
+		map = reinterpret_cast<uintptr_t>(
+				mmap(nullptr, *stack_size + *guard_size,
+					PROT_NONE,
+					MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+				);
+		if (reinterpret_cast<void*>(map) == MAP_FAILED)
+			return EAGAIN;
+		int ret = mprotect(reinterpret_cast<void*>(map + *guard_size), *stack_size,
+				PROT_READ | PROT_WRITE);
+		if(ret)
+			return EAGAIN;
+	}
+
+	auto sp = reinterpret_cast<uintptr_t*>(map + *stack_size + *guard_size);
 	*--sp = reinterpret_cast<uintptr_t>(user_arg);
 	*--sp = reinterpret_cast<uintptr_t>(entry);
-	return sp;
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
 }
 } // namespace mlibc
diff --git a/sysdeps/managarm/aarch64/thread.cpp b/sysdeps/managarm/aarch64/thread.cpp
index 48029b5..d0d00ba 100644
--- a/sysdeps/managarm/aarch64/thread.cpp
+++ b/sysdeps/managarm/aarch64/thread.cpp
@@ -28,17 +28,29 @@ extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
 
 namespace mlibc {
 
-void *prepare_stack(void *entry, void *user_arg, void *tcb) {
-	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
-			mmap(nullptr, 0x1000000,
-				PROT_READ | PROT_WRITE,
-				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-			) + 0x1000000);
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+	*guard_size = 0;
+
+	uintptr_t *sp;
+	if (*stack) {
+		sp = reinterpret_cast<uintptr_t *>(*stack);
+	} else {
+		sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
+					mmap(nullptr, *stack_size,
+						PROT_READ | PROT_WRITE,
+						MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+					) + *stack_size);
+	}
 
 	*--sp = reinterpret_cast<uintptr_t>(tcb);
 	*--sp = reinterpret_cast<uintptr_t>(user_arg);
 	*--sp = reinterpret_cast<uintptr_t>(entry);
-	return sp;
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
 }
 
 } //namespace mlibc
diff --git a/sysdeps/managarm/generic/fork-exec.cpp b/sysdeps/managarm/generic/fork-exec.cpp
index 88ca04a..80db6ce 100644
--- a/sysdeps/managarm/generic/fork-exec.cpp
+++ b/sysdeps/managarm/generic/fork-exec.cpp
@@ -618,14 +618,11 @@ int sys_getrusage(int scope, struct rusage *usage) {
 	return 0;
 }
 
-int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *pid_out) {
+int sys_clone(void *tcb, pid_t *pid_out, void *stack) {
 	HelWord pid = 0;
-
-	void *sp = prepare_stack(entry, user_arg, tcb);
-
 	HEL_CHECK(helSyscall2_1(kHelCallSuper + 9,
 				reinterpret_cast<HelWord>(__mlibc_start_thread),
-				reinterpret_cast<HelWord>(sp),
+				reinterpret_cast<HelWord>(stack),
 				&pid));
 
 	if (pid_out)
diff --git a/sysdeps/managarm/x86_64/thread.cpp b/sysdeps/managarm/x86_64/thread.cpp
index 48029b5..d0d00ba 100644
--- a/sysdeps/managarm/x86_64/thread.cpp
+++ b/sysdeps/managarm/x86_64/thread.cpp
@@ -28,17 +28,29 @@ extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
 
 namespace mlibc {
 
-void *prepare_stack(void *entry, void *user_arg, void *tcb) {
-	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
-			mmap(nullptr, 0x1000000,
-				PROT_READ | PROT_WRITE,
-				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-			) + 0x1000000);
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+	*guard_size = 0;
+
+	uintptr_t *sp;
+	if (*stack) {
+		sp = reinterpret_cast<uintptr_t *>(*stack);
+	} else {
+		sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
+					mmap(nullptr, *stack_size,
+						PROT_READ | PROT_WRITE,
+						MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+					) + *stack_size);
+	}
 
 	*--sp = reinterpret_cast<uintptr_t>(tcb);
 	*--sp = reinterpret_cast<uintptr_t>(user_arg);
 	*--sp = reinterpret_cast<uintptr_t>(entry);
-	return sp;
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
 }
 
 } //namespace mlibc
diff --git a/sysdeps/vinix/crt-x86_64/crt0.S b/sysdeps/vinix/crt-x86_64/crt0.S
new file mode 100644
index 0000000..06ab8a7
--- /dev/null
+++ b/sysdeps/vinix/crt-x86_64/crt0.S
@@ -0,0 +1,5 @@
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
diff --git a/sysdeps/vinix/generic/entry.cpp b/sysdeps/vinix/generic/entry.cpp
new file mode 100644
index 0000000..e7c792b
--- /dev/null
+++ b/sysdeps/vinix/generic/entry.cpp
@@ -0,0 +1,99 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/elf/startup.h>
+#include <mlibc/all-sysdeps.hpp>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+struct GPRState {
+	uint64_t ds;
+	uint64_t es;
+	uint64_t rax;
+	uint64_t rbx;
+	uint64_t rcx;
+	uint64_t rdx;
+	uint64_t rsi;
+	uint64_t rdi;
+	uint64_t rbp;
+	uint64_t r8;
+	uint64_t r9;
+	uint64_t r10;
+	uint64_t r11;
+	uint64_t r12;
+	uint64_t r13;
+	uint64_t r14;
+	uint64_t r15;
+	uint64_t err;
+	uint64_t rip;
+	uint64_t cs;
+	uint64_t rflags;
+	uint64_t rsp;
+	uint64_t ss;
+};
+
+static void __mlibc_sigentry(int which, siginfo_t *siginfo,
+                             void (*sa)(int, siginfo_t *, void *),
+                             GPRState *ret_context, sigset_t prev_mask) {
+    size_t *base_ptr = (size_t *)ret_context->rbp;
+    mlibc::infoLogger() << "Stacktrace:" << frg::endlog;
+    mlibc::infoLogger() << "  [" << (void *)ret_context->rip << "]" << frg::endlog;
+    for (;;) {
+        size_t old_bp = base_ptr[0];
+        size_t ret_addr = base_ptr[1];
+        if (!ret_addr)
+            break;
+        size_t off;
+        mlibc::infoLogger() << "  [" << (void *)ret_addr << "]" << frg::endlog;
+        if (!old_bp)
+            break;
+        base_ptr = (size_t *)old_bp;
+    }
+
+    switch ((uintptr_t)sa) {
+        // DFL
+        case (uintptr_t)(-2):
+            mlibc::infoLogger() << "mlibc: Unhandled signal " << which << frg::endlog;
+            mlibc::sys_exit(128 + which);
+        // IGN
+        case (uintptr_t)(-3):
+            break;
+        default:
+            sa(which, siginfo, NULL);
+            break;
+    }
+
+    mlibc::sys_sigreturn(ret_context, prev_mask);
+
+    __builtin_unreachable();
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+    mlibc::sys_sigentry((void *)__mlibc_sigentry);
+
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git a/sysdeps/vinix/generic/generic.cpp b/sysdeps/vinix/generic/generic.cpp
new file mode 100644
index 0000000..dc37489
--- /dev/null
+++ b/sysdeps/vinix/generic/generic.cpp
@@ -0,0 +1,785 @@
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+
+#define STUB_ONLY {                             \
+    __ensure(!"STUB_ONLY function was called"); \
+    __builtin_unreachable();                    \
+}
+
+struct __syscall_ret {
+    uint64_t ret;
+    uint64_t errno;
+};
+
+__attribute__((naked))
+static __syscall_ret __syscall(int number, ...) {
+    asm (
+        "mov %rcx, %r10\n\t"
+        "syscall\n\t"
+        "ret"
+    );
+}
+
+namespace mlibc {
+
+void sys_libc_log(const char *message) {
+    __syscall(0, message);
+}
+
+void sys_libc_panic() {
+    sys_libc_log("\nMLIBC PANIC\n");
+    sys_exit(1);
+    __builtin_unreachable();
+}
+
+void sys_exit(int status) {
+    __syscall(15, status);
+    __builtin_unreachable();
+}
+
+int sys_kill(pid_t pid, int signal) {
+    __syscall_ret ret = __syscall(26, pid, signal);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_tcgetattr(int fd, struct termios *attr) {
+    int ret;
+
+    if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
+        return r;
+    }
+
+    return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
+    int ret;
+
+    switch (optional_action) {
+        case TCSANOW:
+            optional_action = TCSETS; break;
+        case TCSADRAIN:
+            optional_action = TCSETSW; break;
+        case TCSAFLUSH:
+            optional_action = TCSETSF; break;
+        default:
+            __ensure(!"Unsupported tcsetattr");
+    }
+
+    if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
+        return r;
+    }
+
+    return 0;
+}
+
+int sys_tcb_set(void *pointer) {
+    __syscall(7, pointer);
+    return 0;
+}
+
+int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout,
+        const sigset_t *sigmask, int *num_events) {
+    __syscall_ret ret = __syscall(36, fds, nfds, timeout, sigmask);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *num_events = (int)ret.ret;
+    return 0;
+}
+
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+    struct timespec ts;
+    ts.tv_sec = timeout / 1000;
+    ts.tv_nsec = (timeout % 1000) * 1000000;
+    return sys_ppoll(fds, count, &ts, NULL, num_events);
+}
+
+int sys_epoll_pwait(int epfd, struct epoll_event *ev, int n,
+                    int timeout, const sigset_t *sigmask, int *raised) {
+    __syscall_ret ret = __syscall(49, epfd, ev, n, timeout, sigmask);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *raised = (int)ret.ret;
+    return 0;
+}
+
+int sys_epoll_create(int flags, int *fd) {
+    __syscall_ret ret = __syscall(37, flags);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_epoll_ctl(int epfd, int mode, int fd, struct epoll_event *ev) {
+    __syscall_ret ret = __syscall(47, epfd, mode, fd, ev);
+
+    return ret.errno;
+}
+
+#ifndef MLIBC_BUILDING_RTDL
+int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
+        fd_set *except_set, const struct timespec *timeout,
+        const sigset_t *sigmask, int *num_events) {
+    struct pollfd *fds = (struct pollfd *)malloc(nfds * sizeof(struct pollfd));
+
+    for (int i = 0; i < nfds; i++) {
+        struct pollfd *fd = &fds[i];
+        memset(fd, 0, sizeof(struct pollfd));
+
+        if (read_set && FD_ISSET(i, read_set))
+            fd->events |= POLLIN; // TODO: Additional events.
+        if (write_set && FD_ISSET(i, write_set))
+            fd->events |= POLLOUT; // TODO: Additional events.
+        if (except_set && FD_ISSET(i, except_set))
+            fd->events |= POLLPRI;
+
+        if (!fd->events) {
+            fd->fd = -1;
+            continue;
+        }
+
+        fd->fd = i;
+    }
+
+    int e = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+
+    if (e != 0) {
+        free(fds);
+        return e;
+    }
+
+    fd_set res_read_set;
+    fd_set res_write_set;
+    fd_set res_except_set;
+    FD_ZERO(&res_read_set);
+    FD_ZERO(&res_write_set);
+    FD_ZERO(&res_except_set);
+
+    for (int i = 0; i < nfds; i++) {
+        struct pollfd *fd = &fds[i];
+
+        if (read_set && FD_ISSET(i, read_set)
+                && fd->revents & (POLLIN | POLLERR | POLLHUP)) {
+            FD_SET(i, &res_read_set);
+        }
+
+        if (write_set && FD_ISSET(i, write_set)
+                && fd->revents & (POLLOUT | POLLERR | POLLHUP)) {
+            FD_SET(i, &res_write_set);
+        }
+
+        if (except_set && FD_ISSET(i, except_set)
+                && fd->revents & POLLPRI) {
+            FD_SET(i, &res_except_set);
+        }
+    }
+
+    free(fds);
+
+    if (read_set)
+        memcpy(read_set, &res_read_set, sizeof(fd_set));
+    if (write_set)
+        memcpy(write_set, &res_write_set, sizeof(fd_set));
+    if (except_set)
+        memcpy(except_set, &res_except_set, sizeof(fd_set));
+
+    return 0;
+}
+#endif
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+    __syscall_ret ret = __syscall(23, pointer, expected, time);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+    __syscall_ret ret = __syscall(24, pointer);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    int num_woken = ret.ret;
+
+    __ensure(num_woken >= 0 && num_woken <= 1);
+    return num_woken;
+}
+
+int sys_timerfd_create(int flags, int *fd) {
+    __syscall_ret ret = __syscall(54, 0, flags);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+    __syscall_ret ret = __syscall(9, fd, request, arg);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *result = (int)ret.ret;
+    return 0;
+}
+
+int sys_isatty(int fd) {
+    struct winsize ws;
+    int ret;
+
+    if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &ret))
+        return 0;
+
+    return ENOTTY;
+}
+
+int sys_getcwd(char *buffer, size_t size) {
+    __syscall_ret ret = __syscall(25, buffer, size);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_openat(int dirfd, const char *path, int flags, int *fd) {
+    __syscall_ret ret = __syscall(2, dirfd, path, flags, 0);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_open(const char *path, int flags, int *fd) {
+    return sys_openat(AT_FDCWD, path, flags, fd);
+}
+
+int sys_open_dir(const char *path, int *handle) {
+    return sys_open(path, O_DIRECTORY, handle);
+}
+
+int sys_read_entries(int fd, void *buffer, size_t max_size, size_t *bytes_read) {
+    __syscall_ret ret = __syscall(19, fd, buffer);
+
+    if (ret.ret == (uint64_t)-1 && ret.errno == 0) {
+        // End of directory.
+        *bytes_read = 0;
+        return 0;
+    } else if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *bytes_read = sizeof(struct dirent);
+    return 0;
+}
+
+int sys_close(int fd) {
+    __syscall_ret ret = __syscall(6, fd);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+    __syscall_ret ret = __syscall(5, fd, offset, whence);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *new_offset = (off_t)ret.ret;
+    return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+    __syscall_ret ret = __syscall(3, fd, buf, count);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *bytes_read = (ssize_t)ret.ret;
+    return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+    __syscall_ret ret = __syscall(4, fd, buf, count);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *bytes_written = (ssize_t)ret.ret;
+    return 0;
+}
+
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length) {
+    __syscall_ret ret = __syscall(33, AT_FDCWD, path, data, max_size);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *length = (ssize_t)ret.ret;
+    return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path) {
+    return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) {
+    __syscall_ret ret = __syscall(58, olddirfd, old_path, newdirfd, new_path, flags);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_unlinkat(int fd, const char *path, int flags) {
+    __syscall_ret ret = __syscall(35, fd, path, flags);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_fchmod(int fd, mode_t mode) {
+    __syscall_ret ret = __syscall(57, fd, mode);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_rmdir(const char *path) {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags,
+               int fd, off_t offset, void **window) {
+    __syscall_ret ret = __syscall(1, hint, size,
+                                  (uint64_t)prot << 32 | (uint64_t)flags, fd, offset);
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *window = (void *)ret.ret;
+    return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+    __syscall_ret ret = __syscall(34, pointer, size);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_anon_allocate(size_t size, void **pointer) {
+    return sys_vm_map(NULL, size, PROT_EXEC | PROT_READ | PROT_WRITE,
+                      MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size) {
+    return 0;
+}
+
+pid_t sys_getpid() {
+    __syscall_ret ret = __syscall(31);
+
+    return ret.ret;
+}
+
+pid_t sys_getppid() {
+    __syscall_ret ret = __syscall(32);
+
+    return ret.ret;
+}
+
+uid_t sys_getuid() {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+uid_t sys_geteuid() {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+gid_t sys_getgid() {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+int sys_setgid(gid_t gid) {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    *pgid = 0;
+    return 0;
+}
+
+gid_t sys_getegid() {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return 0;
+}
+
+int sys_ttyname(int fd, char *buf, size_t size) {
+    mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
+    return ENOSYS;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+    struct timespec ts;
+    __syscall_ret ret = __syscall(50, clock, &ts);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *secs = ts.tv_sec;
+    *nanos = ts.tv_nsec;
+
+    return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+    switch (fsfdt) {
+        case fsfd_target::fd: {
+            __syscall_ret ret = __syscall(10, fd, statbuf);
+            if (ret.errno != 0)
+                return ret.errno;
+            return ret.ret;
+        }
+        case fsfd_target::path: {
+            __syscall_ret ret = __syscall(11, AT_FDCWD, path, statbuf, flags);
+            if (ret.errno != 0)
+                return ret.errno;
+            return ret.ret;
+        }
+        case fsfd_target::fd_path: {
+            __syscall_ret ret = __syscall(11, fd, path, statbuf, flags);
+            if (ret.errno != 0)
+                return ret.errno;
+            return ret.ret;
+        }
+        default: {
+            __ensure(!"stat: Invalid fsfdt");
+            __builtin_unreachable();
+        }
+    }
+    return 0;
+}
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
+    __syscall_ret ret = __syscall(20, dirfd, pathname, mode, flags);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_access(const char *path, int mode) {
+    return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_pipe(int *fds, int flags) {
+    __syscall_ret ret = __syscall(21, fds, flags);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_chdir(const char *path) {
+    __syscall_ret ret = __syscall(18, path);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    return 0;
+}
+
+int sys_mkdir(const char *path) {
+    return sys_mkdirat(AT_FDCWD, path, 0755);
+}
+
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+    __syscall_ret ret = __syscall(22, dirfd, path, mode);
+
+    return ret.errno;
+}
+
+int sys_socket(int domain, int type_and_flags, int proto, int *fd) {
+    __syscall_ret ret = __syscall(39, domain, type_and_flags, proto);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) {
+    __syscall_ret ret = __syscall(46, domain, type_and_flags, proto, fds);
+
+    return ret.errno;
+}
+
+int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+    __syscall_ret ret = __syscall(40, fd, addr_ptr, addr_length);
+
+    return ret.errno;
+}
+
+int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+    __syscall_ret ret = __syscall(59, fd, addr_ptr, addr_length);
+
+    return ret.errno;
+}
+
+int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+    __syscall_ret ret = __syscall(60, fd, addr_ptr, &max_addr_length);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *actual_length = max_addr_length;
+    return 0;
+}
+
+int sys_listen(int fd, int backlog) {
+    __syscall_ret ret = __syscall(41, fd, backlog);
+
+    return ret.errno;
+}
+
+int sys_inotify_create(int flags, int *fd) {
+    __syscall_ret ret = __syscall(42, flags);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_fork(pid_t *child) {
+    __syscall_ret ret = __syscall(14);
+
+    if (ret.errno != 0) {
+        return ret.errno;
+    }
+
+    *child = (pid_t)ret.ret;
+    return 0;
+}
+
+int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+    __syscall_ret ret = __syscall(17, path, argv, envp);
+
+    return ret.errno;
+}
+
+int sys_fcntl(int fd, int request, va_list args, int *result) {
+    __syscall_ret ret = __syscall(12, fd, request, va_arg(args, uint64_t));
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *result = (ssize_t)ret.ret;
+    return 0;
+}
+
+int sys_dup(int fd, int flags, int *newfd) {
+    __syscall_ret ret = __syscall(12, fd, F_DUPFD, 0);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *newfd = (ssize_t)ret.ret;
+    return 0;
+}
+
+int sys_dup2(int fd, int flags, int newfd) {
+    __syscall_ret ret = __syscall(13, fd, newfd, flags);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sigentry(void *sigentry) {
+    __syscall_ret ret = __syscall(27, sigentry);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
+    __syscall_ret ret = __syscall(28, how, set, retrieve);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
+    __syscall_ret ret = __syscall(29, signum, act, oldact);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sigreturn(void *context, sigset_t old_mask) {
+    __syscall_ret ret = __syscall(30, context, old_mask);
+
+    __builtin_unreachable();
+}
+
+int sys_signalfd_create(sigset_t mask, int flags, int *fd) {
+    __syscall_ret ret = __syscall(45, *fd, mask, flags);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *fd = (int)ret.ret;
+    return 0;
+}
+
+int sys_waitpid(pid_t pid, int *status, int flags, pid_t *ret_pid) {
+again:
+    __syscall_ret ret = __syscall(16, pid, status, flags);
+
+    if (ret.errno != 0) {
+        if (ret.errno == EINTR) {
+            goto again;
+        }
+
+        return ret.errno;
+    }
+
+    *ret_pid = (pid_t)ret.ret;
+    return 0;
+}
+
+int sys_getgroups(size_t size, const gid_t *list, int *_ret) {
+    __syscall_ret ret = __syscall(38, size, list);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *_ret = (int)ret.ret;
+    return 0;
+}
+
+int sys_mount(const char *source, const char *target, const char *fstype, unsigned long flags, const void *data) {
+    __syscall_ret ret = __syscall(43, source, target, fstype, flags, data);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_umount2(const char *target, int flags) {
+    __syscall_ret ret = __syscall(44, target, flags);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_gethostname(char *buffer, size_t bufsize) {
+    __syscall_ret ret = __syscall(51, buffer, bufsize);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sethostname(const char *buffer, size_t bufsize) {
+    __syscall_ret ret = __syscall(52, buffer, bufsize);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    return 0;
+}
+
+int sys_sleep(time_t *secs, long *nanos) {
+    struct timespec req = {
+        .tv_sec = *secs,
+        .tv_nsec = *nanos
+    };
+    struct timespec rem = {0, 0};
+
+    __syscall_ret ret = __syscall(53, &req, &rem);
+
+    if (ret.errno != 0)
+        return ret.errno;
+
+    *secs = rem.tv_sec;
+    *nanos = rem.tv_nsec;
+    return 0;
+}
+
+} // namespace mlibc
diff --git a/sysdeps/vinix/include/abi-bits/abi.h b/sysdeps/vinix/include/abi-bits/abi.h
new file mode 120000
index 0000000..c945860
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/abi.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/abi.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/auxv.h b/sysdeps/vinix/include/abi-bits/auxv.h
new file mode 120000
index 0000000..b7bb109
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/qword/auxv.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/blkcnt_t.h b/sysdeps/vinix/include/abi-bits/blkcnt_t.h
new file mode 120000
index 0000000..e9d9f1b
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/blksize_t.h b/sysdeps/vinix/include/abi-bits/blksize_t.h
new file mode 120000
index 0000000..c6dfb6e
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blksize_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/dev_t.h b/sysdeps/vinix/include/abi-bits/dev_t.h
new file mode 120000
index 0000000..0c1143b
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/dev_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/errno.h b/sysdeps/vinix/include/abi-bits/errno.h
new file mode 120000
index 0000000..589859f
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/errno.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/fcntl.h b/sysdeps/vinix/include/abi-bits/fcntl.h
new file mode 120000
index 0000000..ea5323a
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/fcntl.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/gid_t.h b/sysdeps/vinix/include/abi-bits/gid_t.h
new file mode 120000
index 0000000..6a77218
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/gid_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/in.h b/sysdeps/vinix/include/abi-bits/in.h
new file mode 120000
index 0000000..b58c683
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/in.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/ino_t.h b/sysdeps/vinix/include/abi-bits/ino_t.h
new file mode 120000
index 0000000..10d644e
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/ino_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/limits.h b/sysdeps/vinix/include/abi-bits/limits.h
new file mode 120000
index 0000000..1aa5894
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/limits.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/mode_t.h b/sysdeps/vinix/include/abi-bits/mode_t.h
new file mode 120000
index 0000000..29d7733
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/mode_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/nlink_t.h b/sysdeps/vinix/include/abi-bits/nlink_t.h
new file mode 120000
index 0000000..7618c27
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/nlink_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/pid_t.h b/sysdeps/vinix/include/abi-bits/pid_t.h
new file mode 120000
index 0000000..3fd26a7
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/pid_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/reboot.h b/sysdeps/vinix/include/abi-bits/reboot.h
new file mode 120000
index 0000000..ecc3ddb
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/x86_64/reboot.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/resource.h b/sysdeps/vinix/include/abi-bits/resource.h
new file mode 120000
index 0000000..260b022
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/x86_64/resource.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/seek-whence.h b/sysdeps/vinix/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..3bd41ef
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/signal.h b/sysdeps/vinix/include/abi-bits/signal.h
new file mode 120000
index 0000000..b20e511
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/signal.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/socket.h b/sysdeps/vinix/include/abi-bits/socket.h
new file mode 120000
index 0000000..0e1d6be
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/socket.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/stat.h b/sysdeps/vinix/include/abi-bits/stat.h
new file mode 120000
index 0000000..82642c3
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/stat.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/termios.h b/sysdeps/vinix/include/abi-bits/termios.h
new file mode 120000
index 0000000..6a7d94e
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/x86_64/termios.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/time.h b/sysdeps/vinix/include/abi-bits/time.h
new file mode 120000
index 0000000..97f3d52
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/time.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/uid_t.h b/sysdeps/vinix/include/abi-bits/uid_t.h
new file mode 120000
index 0000000..1113eba
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/uid_t.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/vm-flags.h b/sysdeps/vinix/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..f1a985e
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/vinix/include/abi-bits/wait.h b/sysdeps/vinix/include/abi-bits/wait.h
new file mode 120000
index 0000000..6d911c7
--- /dev/null
+++ b/sysdeps/vinix/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/wait.h
\ No newline at end of file
diff --git a/sysdeps/vinix/meson.build b/sysdeps/vinix/meson.build
new file mode 100644
index 0000000..b9e4372
--- /dev/null
+++ b/sysdeps/vinix/meson.build
@@ -0,0 +1,52 @@
+
+rtdl_sources += files(
+	'generic/generic.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/abi.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git a/tests/ansi/sscanf.c b/tests/ansi/sscanf.c
index 8576e93..0253552 100644
--- a/tests/ansi/sscanf.c
+++ b/tests/ansi/sscanf.c
@@ -17,5 +17,12 @@ int main() {
 	assert(!strcmp(def, "process_priority"));
 	assert(!strcmp(strparm, "0"));
 
+	char buf3[] = "fffffffff100";
+	unsigned long y = 0;
+	sscanf(buf3, "%lx", &y);
+	assert(y == 0xfffffffff100);
+	char buf4[] = "410dc000";
+	sscanf(buf4, "%lx", &y);
+	assert(y == 0x410dc000);
 	return 0;
 }
diff --git a/tests/meson.build b/tests/meson.build
index 24a5b86..84c9114 100644
--- a/tests/meson.build
+++ b/tests/meson.build
@@ -25,6 +25,7 @@ posix_test_cases = [
 	'pthread_cleanup',
 	'pthread_kill',
 	'pthread_key',
+	'pthread_attr',
 	'pwd',
 	'getaddrinfo',
 	'getdelim',
diff --git a/tests/posix/pthread_attr.c b/tests/posix/pthread_attr.c
new file mode 100644
index 0000000..c7bf327
--- /dev/null
+++ b/tests/posix/pthread_attr.c
@@ -0,0 +1,174 @@
+#include <pthread.h>
+#include <assert.h>
+#include <errno.h>
+#include <alloca.h>
+#include <sys/mman.h>
+
+static void test_detachstate() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED));
+	int detachstate;
+	assert(!pthread_attr_getdetachstate(&attr, &detachstate));
+	assert(detachstate == PTHREAD_CREATE_DETACHED);
+	assert(pthread_attr_setdetachstate(&attr, 2* (PTHREAD_CREATE_DETACHED +
+				PTHREAD_CREATE_JOINABLE)) == EINVAL);
+}
+
+static void *stacksize_worker(void *arg) {
+	size_t default_stacksize = (*(size_t*)arg);
+	size_t alloc_size = default_stacksize + default_stacksize/2;
+	void *area = alloca(alloc_size);
+	// If the allocated stack was not enough this will crash.
+	*(volatile int*)(area + alloc_size) = 1;
+	return NULL;
+}
+
+static void test_stacksize() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_init(&attr));
+	size_t stacksize;
+	assert(!pthread_attr_getstacksize(&attr, &stacksize));
+	assert(!pthread_attr_setstacksize(&attr, stacksize * 2));
+	pthread_t thread;
+	assert(!pthread_create(&thread, &attr, stacksize_worker, &stacksize));
+	assert(!pthread_join(thread, NULL));
+}
+
+static void test_guardsize() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_init(&attr));
+	assert(!pthread_attr_setguardsize(&attr, 0));
+	size_t guardsize;
+	assert(!pthread_attr_getguardsize(&attr, &guardsize));
+	assert(!guardsize);
+}
+
+static void test_scope() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM));
+	int scope;
+	assert(!pthread_attr_getscope(&attr, &scope));
+	assert(scope == PTHREAD_SCOPE_SYSTEM);
+	assert(pthread_attr_setscope(&attr, 2* (PTHREAD_SCOPE_SYSTEM +
+				PTHREAD_SCOPE_PROCESS)) == EINVAL);
+}
+
+static void test_inheritsched() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED));
+	int inheritsched;
+	assert(!pthread_attr_getinheritsched(&attr, &inheritsched));
+	assert(inheritsched == PTHREAD_INHERIT_SCHED);
+	assert(pthread_attr_setinheritsched(&attr, 2* (PTHREAD_INHERIT_SCHED +
+				PTHREAD_EXPLICIT_SCHED)) == EINVAL);
+}
+
+static void test_schedparam() {
+	pthread_attr_t attr;
+	struct sched_param init_param = {0};
+	assert(!pthread_attr_setschedparam(&attr, &init_param));
+	struct sched_param param = {1};
+	assert(!pthread_attr_getschedparam(&attr, &param));
+	assert(param.sched_priority == init_param.sched_priority);
+}
+
+static void test_schedpolicy() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_setschedpolicy(&attr, SCHED_FIFO));
+	int policy;
+	assert(!pthread_attr_getschedpolicy(&attr, &policy));
+	assert(policy == SCHED_FIFO);
+	assert(pthread_attr_setinheritsched(&attr, 2* (SCHED_FIFO + SCHED_RR +
+				SCHED_OTHER)) == EINVAL);
+}
+
+static void *stackaddr_worker(void *arg) {
+	void *addr = *(void**)arg;
+
+	void *sp;
+#if defined(__x86_64__)
+	asm volatile ("mov %%rsp, %0" : "=r"(sp));
+#elif defined(__aarch64__)
+	asm volatile ("mov %0, sp" : "=r"(sp));
+#else
+#	error Unknown architecture
+#endif
+
+	// Check if our stack pointer is in a sane range.
+	assert(addr < sp);
+	return NULL;
+}
+
+static void test_stackaddr() {
+	pthread_attr_t attr;
+	assert(!pthread_attr_init(&attr));
+	size_t size;
+	assert(!pthread_attr_getstacksize(&attr, &size));
+	void *addr = mmap(NULL, size, PROT_READ | PROT_WRITE,
+				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	assert(!pthread_attr_setstackaddr(&attr, addr));
+	assert(!pthread_attr_setguardsize(&attr, 0));
+	void *new_addr;
+	assert(!pthread_attr_getstackaddr(&attr, &new_addr));
+	assert(new_addr == addr);
+
+	pthread_t thread;
+	assert(!pthread_create(&thread, &attr, stackaddr_worker, &addr));
+	assert(!pthread_join(thread, NULL));
+}
+
+static void test_stack() {
+	pthread_attr_t attr;
+	void *stackaddr = (void*)1;
+	size_t stacksize = PTHREAD_STACK_MIN;
+
+	assert(!pthread_attr_setstack(&attr, stackaddr, stacksize));
+	void *new_addr;
+	size_t new_size;
+	assert(!pthread_attr_getstack(&attr, &new_addr, &new_size));
+	assert(new_addr == stackaddr);
+	assert(new_size == stacksize);
+}
+
+static void *getattr_worker(void *arg) {
+	return NULL;
+}
+
+static void test_getattrnp() {
+	pthread_attr_t attr;
+	size_t stacksize = PTHREAD_STACK_MIN;
+	assert(!pthread_attr_init(&attr));
+	assert(!pthread_attr_setstacksize(&attr, stacksize));
+
+	pthread_t thread;
+	assert(!pthread_create(&thread, &attr, getattr_worker, NULL));
+	assert(!pthread_getattr_np(thread, &attr));
+	size_t other_stacksize;
+	assert(!pthread_attr_getstacksize(&attr, &other_stacksize));
+	assert(other_stacksize == stacksize);
+	assert(!pthread_join(thread, NULL));
+
+	pthread_t own_thread = pthread_self();
+	void *stack;
+	assert(!pthread_getattr_np(own_thread, &attr));
+	assert(!pthread_attr_getstack(&attr, &stack, &other_stacksize));
+	assert(stack);
+	assert(other_stacksize);
+	// Check that we can read from the highest byte returned.
+	// pthread_getattr_np() should return the lowest byte
+	// of the stack.
+	assert(!*(char*)(stack + other_stacksize - 1));
+}
+
+int main() {
+	test_detachstate();
+	test_stacksize();
+	test_guardsize();
+	test_scope();
+	test_inheritsched();
+	test_schedparam();
+	test_schedpolicy();
+	test_stackaddr();
+	test_stack();
+	test_getattrnp();
+}
-- 
2.35.0

